"""统一图构建器

集成所有功能的统一图构建器，包含基础构建、函数注册表集成和迭代管理功能。
"""

from typing import Dict, Any, Optional, List, Callable, Union, TYPE_CHECKING, cast
from pathlib import Path
import yaml
import logging
import asyncio
import concurrent.futures
import time
import threading
from abc import ABC, abstractmethod
from datetime import datetime
from enum import Enum

if TYPE_CHECKING:
    from langchain_core.runnables import RunnableConfig
else:
    # 运行时使用Dict作为RunnableConfig的替代
    RunnableConfig = Dict[str, Any]

from .config import GraphConfig, NodeConfig, EdgeConfig, EdgeType
from .states import WorkflowState
from .states.base import LCBaseMessage
from .registry import NodeRegistry, get_global_registry, BaseNode
from .adapters import get_state_adapter
from src.domain.state.interfaces import IStateCollaborationManager
from .adapters.state_adapter import GraphAgentState
from .function_registry import (
    FunctionRegistry,
    FunctionType,
    get_global_function_registry,
)
from .iteration_manager import IterationManager
from .builtin_functions import get_builtin_node_function, get_builtin_condition_function

logger = logging.getLogger(__name__)

# 导入LangGraph核心组件
from langgraph.graph import StateGraph, START, END
from langchain_core.runnables import RunnableConfig
from langgraph.checkpoint.memory import InMemorySaver
from langgraph.checkpoint.sqlite import SqliteSaver


class INodeExecutor(ABC):
    """节点执行器接口"""
    
    @abstractmethod
    def execute(self, state: WorkflowState, config: "Optional[RunnableConfig]" = None) -> WorkflowState:
        """执行节点逻辑"""
        pass


class NodeWithAdapterExecutor(INodeExecutor):
    """带适配器的节点执行器 - 将图状态与域状态进行转换"""
    
    def __init__(self, node_instance):
        self.node = node_instance
    
    def execute(self, state: WorkflowState, config: "Optional[RunnableConfig]" = None) -> WorkflowState:
        # 确保config不为None
        if config is None:
            config = {}
            
        # 1. 图状态转域状态
        state_adapter = get_state_adapter()
        domain_state = state_adapter.from_graph_state(state)
        
        # 2. 调用节点原始逻辑
        result = self.node.execute(domain_state, config)
        
        # 3. 将结果中的域状态转回图状态
        return cast(WorkflowState, state_adapter.to_graph_state(result.state))


class EnhancedNodeWithAdapterExecutor(INodeExecutor):
    """增强的节点执行器 - 重构版本"""
    
    def __init__(self, node_instance, state_manager: IStateCollaborationManager):
        self.node = node_instance
        from .adapters.collaboration_adapter import CollaborationStateAdapter
        self.collaboration_adapter = CollaborationStateAdapter(state_manager)
    
    def execute(self, state: WorkflowState, config: "Optional[RunnableConfig]" = None) -> WorkflowState:
        """执行节点逻辑，集成状态管理功能"""
        
        # 确保config不为None
        if config is None:
            config = {}
        
        def node_executor(domain_state: Any) -> Any:
            """节点执行函数"""
            # 将域状态转换为图状态供节点使用
            temp_graph_state = self.collaboration_adapter.state_adapter.to_graph_state(domain_state)
            
            # 执行原始节点逻辑
            result_graph_state = self.node.execute(temp_graph_state, config)
            
            # 将结果转换回域状态
            return self.collaboration_adapter.state_adapter.from_graph_state(result_graph_state)
        
        # 使用协作适配器执行
        return cast(WorkflowState, self.collaboration_adapter.execute_with_collaboration(state, node_executor))


class GraphBuilder:
    """统一图构建器
    
    集成所有功能的统一图构建器，包含：
    - 基础图构建功能
    - 函数注册表集成
    - 迭代管理功能
    """
    
    def __init__(
        self,
        node_registry: Optional[NodeRegistry] = None,
        function_registry: Optional[FunctionRegistry] = None,
        enable_function_fallback: bool = True,
        enable_iteration_management: bool = True,
    ) -> None:
        """初始化统一图构建器
        
        Args:
            node_registry: 节点注册表
            function_registry: 函数注册表
            enable_function_fallback: 是否启用函数回退机制
            enable_iteration_management: 是否启用迭代管理
        """
        self.node_registry = node_registry or get_global_registry()
        self.function_registry = function_registry or get_global_function_registry()
        self.enable_function_fallback = enable_function_fallback
        self.enable_iteration_management = enable_iteration_management
        self._checkpointer_cache: Dict[str, Any] = {}
        self.iteration_manager: Optional[IterationManager] = None
        
        logger.debug(f"统一图构建器初始化完成，函数回退: {enable_function_fallback}, 迭代管理: {enable_iteration_management}")
    
    def build_graph(self, config: GraphConfig, state_manager: Optional[IStateCollaborationManager] = None) -> Any:
        """构建LangGraph图
        
        Args:
            config: 图配置
            state_manager: 状态管理器
            
        Returns:
            编译后的LangGraph图
        """
        # 验证配置
        errors = config.validate()
        if errors:
            raise ValueError(f"图配置验证失败: {errors}")
        
        # 如果启用迭代管理，创建迭代管理器
        if self.enable_iteration_management:
            self.iteration_manager = IterationManager(config)
        else:
            self.iteration_manager = None
        
        # 获取状态类
        state_class = config.get_state_class()
        
        # 创建StateGraph
        from langgraph.graph import StateGraph
        builder = StateGraph(state_class)
        
        # 添加节点
        self._add_nodes(builder, config, state_manager)
        
        # 添加边
        self._add_edges(builder, config)
        
        # 设置入口点
        if config.entry_point:
            from langgraph.graph import START
            builder.add_edge(START, config.entry_point)
        
        # 配置检查点
        checkpointer = self._get_checkpointer(config)
        
        # 编译图 - 支持异步执行
        graph = builder.compile(
            checkpointer=checkpointer,
            interrupt_before=config.interrupt_before,
            interrupt_after=config.interrupt_after
        )
        
        logger.info(f"成功构建图: {config.name}")
        return graph
    
    def _add_nodes(self, builder: Any, config: GraphConfig, state_manager: Optional[IStateCollaborationManager] = None) -> None:
        """添加节点到图"""
        for node_name, node_config in config.nodes.items():
            # 获取节点函数
            node_function = self._get_node_function(node_config, state_manager)
            
            if node_function:
                # 根据LangGraph最佳实践添加节点
                builder.add_node(node_name, node_function)
                
                logger.debug(f"添加节点: {node_name}")
            else:
                logger.warning(f"无法找到节点函数: {node_config.function_name}")
    
    def _add_edges(self, builder: Any, config: GraphConfig) -> None:
        """添加边到图"""
        for edge in config.edges:
            if edge.type == EdgeType.SIMPLE:
                # 简单边
                if edge.to_node == "__end__":
                    from langgraph.graph import END
                    builder.add_edge(edge.from_node, END)
                else:
                    builder.add_edge(edge.from_node, edge.to_node)
            elif edge.type == EdgeType.CONDITIONAL:
                # 条件边
                if edge.condition is not None:  # 修复类型问题
                    condition_function = self._get_condition_function(edge.condition)
                    if condition_function:
                        if edge.path_map:
                            builder.add_conditional_edges(
                                edge.from_node, 
                                condition_function,
                                path_map=edge.path_map
                            )
                        else:
                            builder.add_conditional_edges(edge.from_node, condition_function)
                    else:
                        logger.warning(f"无法找到条件函数: {edge.condition}")
                else:
                    logger.warning(f"条件边缺少条件表达式: {edge.from_node} -> {edge.to_node}")
            
            logger.debug(f"添加边: {edge.from_node} -> {edge.to_node}")
    
    def _get_node_function(
        self,
        node_config: NodeConfig,
        state_manager: Optional[IStateCollaborationManager] = None,
    ) -> Optional[Callable]:
        """获取节点函数（统一实现）
        
        优先级：函数注册表 -> 节点注册表 -> 内置函数 -> 父类方法
        
        Args:
            node_config: 节点配置
            state_manager: 状态管理器
            
        Returns:
            Optional[Callable]: 节点函数
        """
        function_name = node_config.function_name
        
        # 1. 优先从函数注册表获取
        if self.function_registry:
            node_function = self.function_registry.get_node_function(function_name)
            if node_function:
                logger.debug(f"从函数注册表获取节点函数: {function_name}")
                return self._wrap_node_function(node_function, state_manager, node_config.name)
        
        # 2. 尝试从节点注册表获取
        if self.node_registry:
            try:
                node_class = self.node_registry.get_node_class(function_name)
                if node_class:
                    node_instance = node_class()
                    logger.debug(f"从节点注册表获取节点函数: {function_name}")
                    return self._wrap_node_function(
                        node_instance.execute, state_manager, node_config.name
                    )
            except ValueError:
                # 节点类型不存在，继续尝试其他方法
                pass
        
        # 3. 尝试从内置函数获取
        builtin_function = get_builtin_node_function(function_name)
        if builtin_function:
            logger.debug(f"从内置函数获取节点函数: {function_name}")
            return self._wrap_node_function(builtin_function, state_manager, node_config.name)
        
        # 4. 如果启用回退，尝试内置实现
        if self.enable_function_fallback:
            builtin_functions = {
                "llm_node": self._create_llm_node,
                "tool_node": self._create_tool_node,
                "analysis_node": self._create_analysis_node,
                "condition_node": self._create_condition_node,
                "wait_node": self._create_wait_node,
            }
            fallback_function = builtin_functions.get(function_name)
            if fallback_function:
                logger.debug(f"从内置回退函数获取节点函数: {function_name}")
                return self._wrap_node_function(fallback_function, state_manager, node_config.name)
        
        logger.warning(f"无法找到节点函数: {function_name}")
        return None
    
    def _get_condition_function(self, condition_name: str) -> Optional[Callable]:
        """获取条件函数（统一实现）
        
        优先级：函数注册表 -> 内置条件 -> 父类方法
        
        Args:
            condition_name: 条件函数名称
            
        Returns:
            Optional[Callable]: 条件函数
        """
        # 1. 优先从函数注册表获取
        if self.function_registry:
            condition_function = self.function_registry.get_condition_function(
                condition_name
            )
            if condition_function:
                logger.debug(f"从函数注册表获取条件函数: {condition_name}")
                return condition_function
        
        # 2. 尝试从内置函数获取
        builtin_function = get_builtin_condition_function(condition_name)
        if builtin_function:
            logger.debug(f"从内置函数获取条件函数: {condition_name}")
            return builtin_function
        
        # 3. 如果启用回退，尝试内置实现
        if self.enable_function_fallback:
            builtin_conditions = {
                "has_tool_calls": self._condition_has_tool_calls,
                "needs_more_info": self._condition_needs_more_info,
                "is_complete": self._condition_is_complete,
            }
            fallback_function = builtin_conditions.get(condition_name)
            if fallback_function:
                logger.debug(f"从内置回退函数获取条件函数: {condition_name}")
                return fallback_function
        
        logger.warning(f"无法找到条件函数: {condition_name}")
        return None
    
    def _wrap_node_function(
        self,
        function: Callable,
        state_manager: Optional[IStateCollaborationManager] = None,
        node_name: str = "unknown",
    ) -> Callable:
        """包装节点函数以支持状态管理和迭代管理
        
        Args:
            function: 原始节点函数
            state_manager: 状态管理器
            node_name: 节点名称
            
        Returns:
            Callable: 包装后的函数
        """
        # 首先包装状态管理
        if state_manager is not None:
            # 如果有状态管理器，使用增强的执行器包装
            from .adapters.collaboration_adapter import CollaborationStateAdapter
            
            def state_wrapped_function(state: Union[WorkflowState, Dict[str, Any]]) -> Any:
                """状态管理包装的节点函数"""
                collaboration_adapter = CollaborationStateAdapter(state_manager)
                
                def node_executor(domain_state: Any) -> Any:
                    """节点执行函数"""
                    # 将域状态转换为图状态
                    temp_graph_state = collaboration_adapter.state_adapter.to_graph_state(domain_state)
                    # 执行原始函数
                    result = function(temp_graph_state)
                    # 将结果转换回域状态
                    return collaboration_adapter.state_adapter.from_graph_state(result)
                
                # 使用协作适配器执行
                return collaboration_adapter.execute_with_collaboration(state, node_executor)
            
            wrapped_function = state_wrapped_function
        else:
            # 如果没有状态管理器，直接使用原函数
            wrapped_function = function
        
        # 然后包装迭代管理（如果启用）
        if self.enable_iteration_management and self.iteration_manager is not None:
            # 使用类型断言确保iteration_manager不是None
            iteration_manager = self.iteration_manager
            
            def iteration_wrapped_function(state: Union[WorkflowState, Dict[str, Any]]) -> Any:
                """迭代管理包装的节点函数"""
                # 记录开始时间
                start_time = datetime.now()
                
                try:
                    # 检查迭代限制
                    if not iteration_manager.check_limits(state, node_name):
                        logger.info(f"节点 {node_name} 达到迭代限制，提前终止")
                        # 返回表明工作流已完成的状态
                        completed_state = dict(state)
                        completed_state['complete'] = True
                        return completed_state

                    # 执行包装函数
                    result = wrapped_function(state)
                    
                    # 确保结果是字典格式
                    if not isinstance(result, dict):
                        # 如果结果不是字典，尝试将其转换为字典
                        if hasattr(result, '__dict__'):
                            result = result.__dict__
                        else:
                            # 如果无法转换，则使用原始状态
                            result = state
                    
                    # 记录结束时间
                    end_time = datetime.now()
                    
                    # 更新迭代计数
                    # 确保结果中包含原始状态信息
                    updated_result = dict(state, **result)  # 合并原始状态和结果
                    updated_result = iteration_manager.record_and_increment(
                        updated_result,
                        node_name,
                        start_time,
                        end_time,
                        status='SUCCESS'
                    )
                    
                    return updated_result
                    
                except Exception as e:
                    logger.error(f"节点 {node_name} 执行失败: {e}")
                    
                    # 记录结束时间
                    end_time = datetime.now()
                    
                    # 即使出错也要记录迭代
                    error_result = dict(state)
                    error_result = iteration_manager.record_and_increment(
                        error_result,
                        node_name,
                        start_time,
                        end_time,
                        status='FAILURE',
                        error=str(e)
                    )
                    
                    # 添加错误信息到状态
                    errors = error_result.get('errors', [])
                    errors.append(f"节点 {node_name} 执行失败: {str(e)}")
                    error_result['errors'] = errors
                    
                    return error_result
            
            return iteration_wrapped_function
        else:
            # 如果不启用迭代管理，直接返回状态包装的函数
            return wrapped_function
    
    def _get_checkpointer(self, config: GraphConfig) -> Optional[Any]:
        """获取检查点"""
        if not config.checkpointer:
            return None
        
        if config.checkpointer in self._checkpointer_cache:
            return self._checkpointer_cache[config.checkpointer]
        
        checkpointer = None
        if config.checkpointer == "memory":
            from langgraph.checkpoint.memory import InMemorySaver
            checkpointer = InMemorySaver()
        elif config.checkpointer.startswith("sqlite:"):
            # sqlite:/path/to/db.sqlite
            from langgraph.checkpoint.sqlite import SqliteSaver
            db_path = config.checkpointer[7:]  # 移除 "sqlite:" 前缀
            checkpointer = SqliteSaver.from_conn_string(f"sqlite:///{db_path}")
        
        if checkpointer:
            self._checkpointer_cache[config.checkpointer] = checkpointer
        
        return checkpointer
    
    # 内置函数实现（用于回退）
    def _create_llm_node(self, state: WorkflowState) -> Dict[str, Any]:
        """创建LLM节点"""
        # 这里应该调用实际的LLM服务
        # 简化实现
        return {"messages": state.get("messages", []) + [{"role": "assistant", "content": "LLM响应"}]}
    
    def _create_tool_node(self, state: WorkflowState) -> Dict[str, Any]:
        """创建工具节点"""
        # 这里应该调用实际的工具服务
        # 简化实现
        return {"tool_results": state.get("tool_calls", [])}
    
    def _create_analysis_node(self, state: WorkflowState) -> Dict[str, Any]:
        """创建分析节点"""
        # 这里应该执行实际的分析逻辑
        # 简化实现
        return {"analysis": "分析结果"}
    
    def _create_condition_node(self, state: WorkflowState) -> Dict[str, Any]:
        """创建条件节点"""
        # 这里应该执行实际的条件判断
        # 简化实现
        return {"condition_result": True}
    
    def _create_wait_node(self, state: WorkflowState) -> Dict[str, Any]:
        """创建等待节点"""
        # 这里应该执行实际的等待逻辑
        # 简化实现 - 返回等待状态
        return {
            "is_waiting": True,
            "wait_start_time": state.get("wait_start_time", time.time()),
            "messages": state.get("messages", []) + [{"role": "system", "content": "等待中..."}]
        }
    
    def _condition_has_tool_calls(self, state: WorkflowState) -> str:
        """条件：是否有工具调用"""
        return "tool_node" if state.get("tool_calls") else "llm_node"
    
    def _condition_needs_more_info(self, state: WorkflowState) -> str:
        """条件：是否需要更多信息"""
        return "analysis_node" if not state.get("analysis") else "end"
    
    def _condition_is_complete(self, state: WorkflowState) -> str:
        """条件：是否完成"""
        return "end" if state.get("complete") else "continue"
    
    # 增强功能方法（来自EnhancedGraphBuilder）
    def register_function(
        self, name: str, function: Callable, function_type: FunctionType
    ) -> None:
        """注册函数到函数注册表
        
        Args:
            name: 函数名称
            function: 函数对象
            function_type: 函数类型
        """
        if self.function_registry:
            self.function_registry.register(name, function, function_type)
            logger.debug(f"注册函数: {name} ({function_type.value})")
        else:
            logger.warning("函数注册表未初始化，无法注册函数")
    
    def unregister_function(self, name: str, function_type: FunctionType) -> bool:
        """从函数注册表注销函数
        
        Args:
            name: 函数名称
            function_type: 函数类型
            
        Returns:
            bool: 是否成功注销
        """
        if self.function_registry:
            result = self.function_registry.unregister(name, function_type)
            if result:
                logger.debug(f"注销函数: {name} ({function_type.value})")
            return result
        else:
            logger.warning("函数注册表未初始化，无法注销函数")
            return False
    
    def list_registered_functions(
        self, function_type: Optional[FunctionType] = None
    ) -> Dict[str, List[str]]:
        """列出已注册的函数
        
        Args:
            function_type: 函数类型过滤器
            
        Returns:
            Dict[str, List[str]]: 函数分类列表
        """
        if self.function_registry:
            return self.function_registry.list_functions(function_type)
        else:
            logger.warning("函数注册表未初始化")
            return {"nodes": [], "conditions": []}
    
    def validate_function_exists(self, name: str, function_type: FunctionType) -> bool:
        """验证函数是否存在
        
        Args:
            name: 函数名称
            function_type: 函数类型
            
        Returns:
            bool: 函数是否存在
        """
        if self.function_registry:
            return self.function_registry.validate_function_exists(name, function_type)
        else:
            logger.warning("函数注册表未初始化")
            return False
    
    def get_function_info(
        self, name: str, function_type: FunctionType
    ) -> Optional[Dict[str, Any]]:
        """获取函数信息
        
        Args:
            name: 函数名称
            function_type: 函数类型
            
        Returns:
            Optional[Dict[str, Any]]: 函数信息
        """
        if self.function_registry:
            return self.function_registry.get_function_info(name, function_type)
        else:
            logger.warning("函数注册表未初始化")
            return None
    
    def discover_functions(
        self, module_paths: Optional[List[str]] = None
    ) -> Dict[str, List[str]]:
        """自动发现并注册函数
        
        Args:
            module_paths: 要扫描的模块路径列表
            
        Returns:
            Dict[str, List[str]]: 发现的函数统计信息
        """
        if self.function_registry:
            return self.function_registry.discover_functions(module_paths)
        else:
            logger.warning("函数注册表未初始化，无法进行函数发现")
            return {"nodes": [], "conditions": []}
    
    def validate_config_functions(self, config: Any) -> List[str]:
        """验证配置中的函数是否存在
        
        Args:
            config: 图配置
            
        Returns:
            List[str]: 验证错误列表
        """
        errors = []
        
        if not self.function_registry:
            errors.append("函数注册表未初始化")
            return errors
        
        # 验证节点函数
        for node_name, node_config in config.nodes.items():
            function_name = node_config.function_name
            if not self.function_registry.validate_function_exists(
                function_name, FunctionType.NODE_FUNCTION
            ):
                errors.append(f"节点 '{node_name}' 引用的函数 '{function_name}' 不存在")
        
        # 验证条件函数
        for edge in config.edges:
            if edge.condition and not self.function_registry.validate_function_exists(
                edge.condition, FunctionType.CONDITION_FUNCTION
            ):
                errors.append(
                    f"边 '{edge.from_node}' -> '{edge.to_node}' 引用的条件函数 '{edge.condition}' 不存在"
                )
        
        return errors
    
    def build_graph_with_validation(
        self, config: Any, state_manager: Optional[IStateCollaborationManager] = None
    ) -> Any:
        """构建图并进行验证
        
        Args:
            config: 图配置
            state_manager: 状态管理器
            
        Returns:
            构建的图
            
        Raises:
            ValueError: 配置验证失败
        """
        # 验证配置中的函数
        function_errors = self.validate_config_functions(config)
        if function_errors:
            raise ValueError(f"配置验证失败: {'; '.join(function_errors)}")
        
        # 构建图
        return self.build_graph(config, state_manager)
    
    def get_function_statistics(self) -> Dict[str, Any]:
        """获取函数统计信息
        
        Returns:
            Dict[str, Any]: 统计信息
        """
        if not self.function_registry:
            return {"error": "函数注册表未初始化"}
        
        functions = self.function_registry.list_functions()
        
        return {
            "total_node_functions": len(functions.get("nodes", [])),
            "total_condition_functions": len(functions.get("conditions", [])),
            "node_functions": functions.get("nodes", []),
            "condition_functions": functions.get("conditions", []),
            "function_fallback_enabled": self.enable_function_fallback,
            "iteration_management_enabled": self.enable_iteration_management,
        }
    
    # 向后兼容方法
    def build_from_yaml(self, yaml_path: str, state_manager: Optional[IStateCollaborationManager] = None) -> Any:
        """从YAML文件构建图
        
        Args:
            yaml_path: YAML配置文件路径
            
        Returns:
            编译后的LangGraph图
        """
        with open(yaml_path, 'r', encoding='utf-8') as f:
            config_data = yaml.safe_load(f)
        
        config = GraphConfig.from_dict(config_data)
        return self.build_graph(config, state_manager)
    
    def validate_config(self, config: GraphConfig) -> List[str]:
        """验证图配置
        
        Args:
            config: 图配置
            
        Returns:
            验证错误列表
        """
        return config.validate()
    
    def load_workflow_config(self, config_path: str) -> GraphConfig:
        """加载工作流配置
        
        Args:
            config_path: 配置文件路径
            
        Returns:
            工作流配置
        """
        with open(config_path, 'r', encoding='utf-8') as f:
            config_data = yaml.safe_load(f)
        
        return GraphConfig.from_dict(config_data)

def get_workflow_builder(*args, **kwargs):
    """获取工作流构建器实例（向后兼容）"""
    return GraphBuilder(*args, **kwargs)