# Sessions和Threads模块迁移方案

## 迁移目标

将 `src\domain\sessions` 和 `src\domain\threads` 目录从旧架构迁移到新架构，遵循扁平化架构原则：
- **Interfaces** → 接口定义层
- **Core** → 核心实体和基础逻辑层  
- **Services** → 业务逻辑服务层
- **Adapters** → 外部适配器层

## 迁移原则

1. **接口集中**：所有接口定义集中到 `src/interfaces` 目录
2. **避免循环导入**：通过接口层解耦，确保依赖方向正确
3. **保持向后兼容**：在迁移期间提供兼容性支持
4. **渐进式迁移**：分步骤进行，确保系统稳定运行

## 当前架构分析

### Sessions模块（src\domain\sessions）
```
sessions/
├── store.py          # ISessionStore接口 + FileSessionStore + MemorySessionStore
```

### Threads模块（src\domain\threads）
```
threads/
├── interfaces.py     # IThreadRepository, IThreadDomainService, IThreadBranchRepository, IThreadSnapshotRepository
├── models.py         # Thread, ThreadBranch, ThreadSnapshot, ThreadHistory, ThreadState实体
├── domain_service.py # ThreadDomainService实现
├── repository.py     # ThreadRepository, ThreadBranchRepository, ThreadSnapshotRepository实现
└── collaboration.py  # Thread协作相关数据模型
```

## 新架构目标位置

### Sessions模块迁移目标
```
src/
├── interfaces/
│   └── sessions/          # 新建 - 会话接口定义
│       ├── __init__.py
│       ├── interfaces.py  # ISessionStore接口
│       └── base.py        # 基础会话接口
├── core/
│   └── sessions/          # 新建 - 会话核心实体
│       ├── __init__.py
│       ├── entities.py    # 会话实体定义
│       ├── interfaces.py  # 核心会话接口
│       └── exceptions.py  # 会话相关异常
├── services/
│   └── sessions/          # 新建 - 会话服务
│       ├── __init__.py
│       ├── manager.py     # 会话管理器服务
│       └── lifecycle.py   # 会话生命周期管理
└── adapters/
    └── storage/           # 扩展现有存储适配器
        ├── __init__.py
        ├── sessions.py    # FileSessionStore, MemorySessionStore迁移至此
        └── base.py        # 存储适配器基类
```

### Threads模块迁移目标
```
src/
├── interfaces/
│   └── threads/           # 新建 - 线程接口定义
│       ├── __init__.py
│       ├── interfaces.py  # IThreadRepository, IThreadDomainService等
│       ├── base.py        # 基础线程接口
│       └── collaboration.py # 协作接口
├── core/
│   └── threads/           # 新建 - 线程核心实体
│       ├── __init__.py
│       ├── entities.py    # Thread, ThreadBranch, ThreadSnapshot等实体
│       ├── interfaces.py  # 核心线程接口
│       └── exceptions.py  # 线程相关异常
├── services/
│   └── threads/           # 新建 - 线程服务
│       ├── __init__.py
│       ├── manager.py     # 线程管理服务
│       ├── coordinator.py # 线程协调器
│       ├── branching.py   # 线程分支管理
│       └── domain_service.py # ThreadDomainService实现迁移
└── adapters/
    └── storage/           # 扩展现有存储适配器
        ├── __init__.py
        ├── threads.py     # ThreadRepository等实现迁移至此
        └── base.py        # 存储适配器基类
```

## 详细迁移步骤

### 第一步：创建接口层（src/interfaces）

#### 1.1 创建Sessions接口目录
```bash
mkdir -p src/interfaces/sessions
```

**文件：src/interfaces/sessions/__init__.py**
```python
"""会话管理接口定义"""

from .interfaces import ISessionStore
from .base import ISessionManager

__all__ = ["ISessionStore", "ISessionManager"]
```

**文件：src/interfaces/sessions/interfaces.py**
```python
"""会话存储接口定义"""

from abc import ABC, abstractmethod
from typing import Dict, Any, Optional, List


class ISessionStore(ABC):
    """会话存储接口"""

    @abstractmethod
    def save_session(self, session_id: str, session_data: Dict[str, Any]) -> bool:
        """保存会话数据"""
        pass

    @abstractmethod
    def get_session(self, session_id: str) -> Optional[Dict[str, Any]]:
        """获取会话数据"""
        pass

    @abstractmethod
    def delete_session(self, session_id: str) -> bool:
        """删除会话数据"""
        pass

    @abstractmethod
    def list_sessions(self) -> List[Dict[str, Any]]:
        """列出所有会话"""
        pass

    @abstractmethod
    def session_exists(self, session_id: str) -> bool:
        """检查会话是否存在"""
        pass
```

**文件：src/interfaces/sessions/base.py**
```python
"""会话管理基础接口"""

from abc import ABC, abstractmethod
from typing import Dict, Any, Optional, List


class ISessionManager(ABC):
    """会话管理器接口"""

    @abstractmethod
    async def create_session(self, workflow_config_path: str, metadata: Optional[Dict[str, Any]] = None) -> str:
        """创建新会话"""
        pass

    @abstractmethod
    async def get_session(self, session_id: str) -> Optional[Dict[str, Any]]:
        """获取会话信息"""
        pass

    @abstractmethod
    async def delete_session(self, session_id: str) -> bool:
        """删除会话"""
        pass

    @abstractmethod
    async def list_sessions(self, filters: Optional[Dict[str, Any]] = None) -> List[Dict[str, Any]]:
        """列出会话"""
        pass
```

#### 1.2 创建Threads接口目录
```bash
mkdir -p src/interfaces/threads
```

**文件：src/interfaces/threads/__init__.py**
```python
"""线程管理接口定义"""

from .interfaces import (
    IThreadRepository,
    IThreadDomainService,
    IThreadBranchRepository,
    IThreadSnapshotRepository,
)
from .base import IThreadManager
from .collaboration import IThreadCollaborationService

__all__ = [
    "IThreadRepository",
    "IThreadDomainService", 
    "IThreadBranchRepository",
    "IThreadSnapshotRepository",
    "IThreadManager",
    "IThreadCollaborationService",
]
```

**文件：src/interfaces/threads/interfaces.py**
```python
"""线程相关接口定义"""

from abc import ABC, abstractmethod
from typing import Dict, Any, Optional, List
from datetime import datetime


class IThreadRepository(ABC):
    """线程仓储接口"""

    @abstractmethod
    async def save(self, thread_data: Dict[str, Any]) -> bool:
        """保存线程数据"""
        pass

    @abstractmethod
    async def find_by_id(self, thread_id: str) -> Optional[Dict[str, Any]]:
        """根据ID查找线程"""
        pass

    @abstractmethod
    async def delete(self, thread_id: str) -> bool:
        """删除线程"""
        pass

    @abstractmethod
    async def find_all(self, filters: Optional[Dict[str, Any]] = None) -> List[Dict[str, Any]]:
        """查找所有线程"""
        pass

    @abstractmethod
    async def exists(self, thread_id: str) -> bool:
        """检查线程是否存在"""
        pass


class IThreadDomainService(ABC):
    """线程领域服务接口"""

    @abstractmethod
    async def create_thread(self, graph_id: str, metadata: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """创建新线程"""
        pass

    @abstractmethod
    async def create_thread_from_config(self, config_path: str, metadata: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """从配置文件创建线程"""
        pass

    @abstractmethod
    async def fork_thread(self, source_thread_id: str, checkpoint_id: str, branch_name: str, metadata: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """创建线程分支"""
        pass

    @abstractmethod
    async def validate_thread_state(self, thread_id: str, state: Dict[str, Any]) -> bool:
        """验证线程状态"""
        pass


class IThreadBranchRepository(ABC):
    """线程分支仓储接口"""

    @abstractmethod
    async def save(self, branch_data: Dict[str, Any]) -> bool:
        """保存分支信息"""
        pass

    @abstractmethod
    async def find_by_id(self, branch_id: str) -> Optional[Dict[str, Any]]:
        """根据ID查找分支"""
        pass

    @abstractmethod
    async def find_by_thread(self, thread_id: str) -> List[Dict[str, Any]]:
        """查找线程的所有分支"""
        pass

    @abstractmethod
    async def delete(self, branch_id: str) -> bool:
        """删除分支"""
        pass


class IThreadSnapshotRepository(ABC):
    """线程快照仓储接口"""

    @abstractmethod
    async def save(self, snapshot_data: Dict[str, Any]) -> bool:
        """保存快照信息"""
        pass

    @abstractmethod
    async def find_by_id(self, snapshot_id: str) -> Optional[Dict[str, Any]]:
        """根据ID查找快照"""
        pass

    @abstractmethod
    async def find_by_thread(self, thread_id: str) -> List[Dict[str, Any]]:
        """查找线程的所有快照"""
        pass

    @abstractmethod
    async def delete(self, snapshot_id: str) -> bool:
        """删除快照"""
        pass
```

### 第二步：创建核心层（src/core）

#### 2.1 创建Sessions核心目录
```bash
mkdir -p src/core/sessions
```

**文件：src/core/sessions/__init__.py**
```python
"""会话管理核心模块"""

from .entities import Session, SessionMetadata
from .interfaces import ISessionCore
from .exceptions import SessionException, SessionNotFoundException

__all__ = [
    "Session",
    "SessionMetadata", 
    "ISessionCore",
    "SessionException",
    "SessionNotFoundException",
]
```

**文件：src/core/sessions/entities.py**
```python
"""会话实体定义"""

from dataclasses import dataclass, field
from typing import Dict, Any, Optional
from datetime import datetime
import uuid


@dataclass
class SessionMetadata:
    """会话元数据"""
    session_id: str
    workflow_config_path: str
    status: str = "active"
    created_at: datetime = field(default_factory=datetime.now)
    updated_at: datetime = field(default_factory=datetime.now)
    metadata: Dict[str, Any] = field(default_factory=dict)

    def update_status(self, new_status: str) -> None:
        """更新状态"""
        self.status = new_status
        self.updated_at = datetime.now()

    def update_metadata(self, updates: Dict[str, Any]) -> None:
        """更新元数据"""
        self.metadata.update(updates)
        self.updated_at = datetime.now()


@dataclass
class Session:
    """会话实体"""
    metadata: SessionMetadata
    state_data: Dict[str, Any] = field(default_factory=dict)
    checkpoint_ids: list = field(default_factory=list)

    @classmethod
    def create(cls, workflow_config_path: str, metadata: Optional[Dict[str, Any]] = None) -> "Session":
        """创建新会话"""
        session_id = f"session_{uuid.uuid4().hex[:8]}"
        session_metadata = SessionMetadata(
            session_id=session_id,
            workflow_config_path=workflow_config_path,
            metadata=metadata or {}
        )
        return cls(metadata=session_metadata)

    def is_active(self) -> bool:
        """检查是否活跃"""
        return self.metadata.status == "active"

    def add_checkpoint(self, checkpoint_id: str) -> None:
        """添加检查点"""
        self.checkpoint_ids.append(checkpoint_id)
```

#### 2.2 创建Threads核心目录
```bash
mkdir -p src/core/threads
```

**文件：src/core/threads/__init__.py**
```python
"""线程管理核心模块"""

from .entities import Thread, ThreadBranch, ThreadSnapshot, ThreadHistory, ThreadState
from .interfaces import IThreadCore
from .exceptions import ThreadException, ThreadNotFoundException

__all__ = [
    "Thread",
    "ThreadBranch",
    "ThreadSnapshot", 
    "ThreadHistory",
    "ThreadState",
    "IThreadCore",
    "ThreadException",
    "ThreadNotFoundException",
]
```

**文件：src/core/threads/entities.py**
```python
"""线程实体定义"""

from dataclasses import dataclass, field
from typing import Dict, Any, List, Optional
from datetime import datetime
import uuid


@dataclass
class Thread:
    """线程核心实体"""
    thread_id: str
    graph_id: str
    status: str = "active"
    created_at: datetime = field(default_factory=datetime.now)
    updated_at: datetime = field(default_factory=datetime.now)
    metadata: Dict[str, Any] = field(default_factory=dict)

    def __post_init__(self):
        """初始化后处理"""
        if isinstance(self.created_at, str):
            self.created_at = datetime.fromisoformat(self.created_at)
        if isinstance(self.updated_at, str):
            self.updated_at = datetime.fromisoformat(self.updated_at)

    def update_status(self, new_status: str) -> None:
        """更新状态"""
        self.status = new_status
        self.updated_at = datetime.now()

    def update_metadata(self, updates: Dict[str, Any]) -> None:
        """更新元数据"""
        self.metadata.update(updates)
        self.updated_at = datetime.now()

    def is_active(self) -> bool:
        """检查是否活跃"""
        return self.status == "active"

    def is_error(self) -> bool:
        """检查是否错误状态"""
        return self.status == "error"

    @classmethod
    def create(cls, graph_id: str, metadata: Optional[Dict[str, Any]] = None) -> "Thread":
        """创建新线程"""
        thread_id = f"thread_{uuid.uuid4().hex[:8]}"
        return cls(
            thread_id=thread_id,
            graph_id=graph_id,
            metadata=metadata or {}
        )


@dataclass
class ThreadBranch:
    """线程分支信息"""
    branch_id: str
    source_thread_id: str
    source_checkpoint_id: str
    branch_name: str
    created_at: datetime
    metadata: Dict[str, Any]
    status: str = "active"

    def __post_init__(self):
        """初始化后处理"""
        if isinstance(self.created_at, str):
            self.created_at = datetime.fromisoformat(self.created_at)


@dataclass
class ThreadSnapshot:
    """线程快照信息"""
    snapshot_id: str
    thread_id: str
    snapshot_name: str
    description: Optional[str]
    checkpoint_ids: List[str]
    created_at: datetime
    metadata: Dict[str, Any]

    def __post_init__(self):
        """初始化后处理"""
        if isinstance(self.created_at, str):
            self.created_at = datetime.fromisoformat(self.created_at)


@dataclass
class ThreadHistory:
    """线程历史记录"""
    thread_id: str
    checkpoints: List[Dict[str, Any]]
    branches: List[ThreadBranch]
    snapshots: List[ThreadSnapshot]


@dataclass
class ThreadState:
    """线程状态"""
    thread_id: str
    state_data: Dict[str, Any]
    checkpoint_id: Optional[str] = None
    created_at: datetime = field(default_factory=datetime.now)
    metadata: Dict[str, Any] = field(default_factory=dict)

    def __post_init__(self):
        """初始化后处理"""
        if isinstance(self.created_at, str):
            self.created_at = datetime.fromisoformat(self.created_at)
```

### 第三步：创建服务层（src/services）

#### 3.1 创建Sessions服务目录
```bash
mkdir -p src/services/sessions
```

**文件：src/services/sessions/__init__.py**
```python
"""会话管理服务"""

from .manager import SessionManager
from .lifecycle import SessionLifecycleManager

__all__ = ["SessionManager", "SessionLifecycleManager"]
```

**文件：src/services/sessions/manager.py**
```python
"""会话管理器服务"""

from typing import Dict, Any, Optional, List
import logging

from ...interfaces.sessions import ISessionManager, ISessionStore
from ...core.sessions import Session, SessionMetadata

logger = logging.getLogger(__name__)


class SessionManager(ISessionManager):
    """会话管理器实现"""

    def __init__(self, session_store: ISessionStore):
        """初始化会话管理器
        
        Args:
            session_store: 会话存储
        """
        self.session_store = session_store

    async def create_session(self, workflow_config_path: str, metadata: Optional[Dict[str, Any]] = None) -> str:
        """创建新会话"""
        try:
            # 创建会话实体
            session = Session.create(workflow_config_path, metadata)
            
            # 保存到存储
            session_data = {
                "session_id": session.metadata.session_id,
                "workflow_config_path": session.metadata.workflow_config_path,
                "status": session.metadata.status,
                "created_at": session.metadata.created_at.isoformat(),
                "updated_at": session.metadata.updated_at.isoformat(),
                "metadata": session.metadata.metadata,
                "state_data": session.state_data,
                "checkpoint_ids": session.checkpoint_ids
            }
            
            success = self.session_store.save_session(session.metadata.session_id, session_data)
            
            if success:
                logger.info(f"创建会话成功: {session.metadata.session_id}")
                return session.metadata.session_id
            else:
                raise RuntimeError("保存会话失败")
                
        except Exception as e:
            logger.error(f"创建会话失败: {e}")
            raise RuntimeError(f"创建会话失败: {e}")

    async def get_session(self, session_id: str) -> Optional[Dict[str, Any]]:
        """获取会话信息"""
        return self.session_store.get_session(session_id)

    async def delete_session(self, session_id: str) -> bool:
        """删除会话"""
        return self.session_store.delete_session(session_id)

    async def list_sessions(self, filters: Optional[Dict[str, Any]] = None) -> List[Dict[str, Any]]:
        """列出会话"""
        sessions = self.session_store.list_sessions()
        
        if not filters:
            return sessions
            
        # 应用过滤条件
        filtered_sessions = []
        for session in sessions:
            if self._matches_filters(session, filters):
                filtered_sessions.append(session)
                
        return filtered_sessions

    def _matches_filters(self, session: Dict[str, Any], filters: Dict[str, Any]) -> bool:
        """检查会话是否匹配过滤条件"""
        for key, value in filters.items():
            if key == "status":
                if session.get("status") != value:
                    return False
            elif key == "workflow_config_path":
                if session.get("workflow_config_path") != value:
                    return False
            elif key == "metadata":
                session_metadata = session.get("metadata", {})
                for meta_key, expected_value in value.items():
                    if session_metadata.get(meta_key) != expected_value:
                        return False
        return True
```

#### 3.2 创建Threads服务目录
```bash
mkdir -p src/services/threads
```

**文件：src/services/threads/__init__.py**
```python
"""线程管理服务"""

from .manager import ThreadManager
from .coordinator import ThreadCoordinator
from .branching import ThreadBranchingService
from .domain_service import ThreadDomainService

__all__ = [
    "ThreadManager",
    "ThreadCoordinator", 
    "ThreadBranchingService",
    "ThreadDomainService",
]
```

**文件：src/services/threads/domain_service.py**
```python
"""线程领域服务实现"""

import uuid
from datetime import datetime
from typing import Dict, Any, Optional
import logging

from ...interfaces.threads import IThreadDomainService, IThreadRepository
from ...core.threads import Thread

logger = logging.getLogger(__name__)


class ThreadDomainService(IThreadDomainService):
    """线程领域服务实现"""

    def __init__(self, thread_repository: IThreadRepository):
        """初始化线程领域服务
        
        Args:
            thread_repository: 线程仓储
        """
        self.thread_repository = thread_repository

    async def create_thread(self, graph_id: str, metadata: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """创建新线程"""
        try:
            # 创建线程实体
            thread = Thread.create(graph_id, metadata)
            
            # 转换为字典格式
            thread_data = {
                "thread_id": thread.thread_id,
                "graph_id": thread.graph_id,
                "status": thread.status,
                "created_at": thread.created_at.isoformat(),
                "updated_at": thread.updated_at.isoformat(),
                "metadata": thread.metadata
            }
            
            # 保存到仓储
            success = await self.thread_repository.save(thread_data)
            
            if success:
                logger.info(f"创建线程成功: {thread.thread_id}, graph_id: {graph_id}")
                return thread_data
            else:
                raise RuntimeError("保存线程失败")
                
        except Exception as e:
            logger.error(f"创建线程失败: {e}")
            raise RuntimeError(f"创建线程失败: {e}")

    async def create_thread_from_config(self, config_path: str, metadata: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """从配置文件创建线程"""
        try:
            # 这里应该加载图配置，暂时简化实现
            graph_id = f"graph_from_{config_path}"
            
            # 合并元数据
            thread_metadata = metadata or {}
            thread_metadata.update({
                "config_path": config_path,
                "config_version": "latest"  # 应该从配置中读取
            })
            
            return await self.create_thread(graph_id, thread_metadata)
            
        except Exception as e:
            logger.error(f"从配置创建线程失败: {e}")
            raise RuntimeError(f"从配置创建线程失败: {e}")

    async def fork_thread(self, source_thread_id: str, checkpoint_id: str, branch_name: str, metadata: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """创建线程分支"""
        try:
            # 获取源线程
            source_thread_data = await self.thread_repository.find_by_id(source_thread_id)
            if not source_thread_data:
                raise ValueError(f"源线程不存在: {source_thread_id}")
            
            # 创建新线程ID
            new_thread_id = f"thread_{uuid.uuid4().hex[:8]}"
            
            # 创建分支元数据
            branch_metadata = {
                "branch_name": branch_name,
                "source_thread_id": source_thread_id,
                "source_checkpoint_id": checkpoint_id,
                "branch_type": "fork",
                **(metadata or {})
            }
            
            # 创建新线程数据
            new_thread_data = {
                "thread_id": new_thread_id,
                "graph_id": source_thread_data["graph_id"],
                "status": "active",
                "created_at": datetime.now().isoformat(),
                "updated_at": datetime.now().isoformat(),
                "metadata": branch_metadata
            }
            
            # 保存新线程
            success = await self.thread_repository.save(new_thread_data)
            
            if success:
                logger.info(f"创建线程分支成功: {new_thread_id}, 源线程: {source_thread_id}")
                return new_thread_data
            else:
                raise RuntimeError("保存线程分支失败")
                
        except Exception as e:
            logger.error(f"创建线程分支失败: {e}")
            raise RuntimeError(f"创建线程分支失败: {e}")

    async def validate_thread_state(self, thread_id: str, state: Dict[str, Any]) -> bool:
        """验证线程状态"""
        try:
            # 基本验证
            if not isinstance(state, dict):
                logger.warning(f"线程状态无效: {thread_id}, 状态不是字典类型")
                return False
            
            # 获取线程信息
            thread_data = await self.thread_repository.find_by_id(thread_id)
            if not thread_data:
                logger.warning(f"线程不存在: {thread_id}")
                return False
            
            # 检查线程是否处于可更新状态
            if thread_data.get("status") == "error":
                logger.warning(f"线程处于错误状态，不允许更新: {thread_id}")
                return False
            
            if thread_data.get("status") == "completed":
                logger.warning(f"线程已完成，不允许更新: {thread_id}")
                return False
            
            logger.debug(f"线程状态验证通过: {thread_id}")
            return True
            
        except Exception as e:
            logger.error(f"验证线程状态失败: {thread_id}, error: {e}")
            return False
```

### 第四步：扩展适配器层（src/adapters/storage）

#### 4.1 扩展现有存储适配器
```bash
# 在现有storage目录下添加新文件
touch src/adapters/storage/sessions.py
```

**文件：src/adapters/storage/sessions.py**
```python
"""会话存储适配器实现"""

import json
import shutil
from pathlib import Path
from typing import Dict, Any, Optional, List

from ...interfaces.sessions import ISessionStore


class FileSessionStore(ISessionStore):
    """基于文件系统的会话存储实现"""

    def __init__(self, storage_path: Path) -> None:
        """初始化文件会话存储
        
        Args:
            storage_path: 存储路径
        """
        self.storage_path = storage_path
        self.storage_path.mkdir(parents=True, exist_ok=True)

    def _get_session_file(self, session_id: str) -> Path:
        """获取会话文件路径"""
        return self.storage_path / f"{session_id}.json"

    def save_session(self, session_id: str, session_data: Dict[str, Any]) -> bool:
        """保存会话数据"""
        session_file = self._get_session_file(session_id)
        temp_file = session_file.with_suffix(".tmp")
        
        try:
            # 创建临时文件
            with open(temp_file, 'w', encoding='utf-8') as f:
                json.dump(session_data, f, ensure_ascii=False, indent=2)
            
            # 原子性替换
            temp_file.replace(session_file)
            
            return True
        except Exception:
            # 清理临时文件
            try:
                if temp_file.exists():
                    temp_file.unlink()
            except Exception:
                pass
            return False

    def get_session(self, session_id: str) -> Optional[Dict[str, Any]]:
        """获取会话数据"""
        try:
            session_file = self._get_session_file(session_id)
            if not session_file.exists():
                return None
                
            with open(session_file, 'r', encoding='utf-8') as f:
                return json.load(f)
        except Exception:
            return None

    def delete_session(self, session_id: str) -> bool:
        """删除会话数据"""
        try:
            session_file = self._get_session_file(session_id)
            if session_file.exists():
                session_file.unlink()
            return True
        except Exception:
            return False

    def list_sessions(self) -> List[Dict[str, Any]]:
        """列出所有会话"""
        sessions = []
        
        try:
            for session_file in self.storage_path.glob("*.json"):
                try:
                    with open(session_file, 'r', encoding='utf-8') as f:
                        session_data = json.load(f)
                        
                    # 添加基本信息
                    metadata = session_data.get("metadata", {})
                    sessions.append({
                        "session_id": metadata.get("session_id", session_file.stem),
                        "workflow_config_path": metadata.get("workflow_config_path"),
                        "created_at": metadata.get("created_at"),
                        "updated_at": metadata.get("updated_at"),
                        "status": metadata.get("status", "unknown")
                    })
                except Exception:
                    # 跳过损坏的会话文件
                    continue
                    
        except Exception:
            pass
            
        return sessions

    def session_exists(self, session_id: str) -> bool:
        """检查会话是否存在"""
        session_file = self._get_session_file(session_id)
        return session_file.exists()


class MemorySessionStore(ISessionStore):
    """基于内存的会话存储实现（用于测试）"""

    def __init__(self) -> None:
        """初始化内存会话存储"""
        self._sessions: Dict[str, Dict[str, Any]] = {}

    def save_session(self, session_id: str, session_data: Dict[str, Any]) -> bool:
        """保存会话数据"""
        try:
            self._sessions[session_id] = session_data.copy()
            return True
        except Exception:
            return False

    def get_session(self, session_id: str) -> Optional[Dict[str, Any]]:
        """获取会话数据"""
        return self._sessions.get(session_id)

    def delete_session(self, session_id: str) -> bool:
        """删除会话数据"""
        if session_id in self._sessions:
            del self._sessions[session_id]
        return True

    def list_sessions(self) -> List[Dict[str, Any]]:
        """列出所有会话"""
        sessions = []
        for session_data in self._sessions.values():
            metadata = session_data.get("metadata", {})
            sessions.append({
                "session_id": metadata.get("session_id"),
                "workflow_config_path": metadata.get("workflow_config_path"),
                "created_at": metadata.get("created_at"),
                "updated_at": metadata.get("updated_at"),
                "status": metadata.get("status", "unknown")
            })
        return sessions

    def session_exists(self, session_id: str) -> bool:
        """检查会话是否存在"""
        return session_id in self._sessions
```

#### 4.2 创建Threads存储适配器
```bash
touch src/adapters/storage/threads.py
```

**文件：src/adapters/storage/threads.py**
```python
"""线程存储适配器实现"""

import json
from pathlib import Path
from typing import Dict, Any, Optional, List
from datetime import datetime

from ...interfaces.threads import IThreadRepository, IThreadBranchRepository, IThreadSnapshotRepository


class ThreadRepository(IThreadRepository):
    """线程仓储实现"""

    def __init__(self, storage_path: Path) -> None:
        """初始化线程仓储
        
        Args:
            storage_path: 存储路径
        """
        self.storage_path = storage_path
        self.threads_path = storage_path / "threads"
        self.threads_path.mkdir(parents=True, exist_ok=True)

    def _get_thread_file(self, thread_id: str) -> Path:
        """获取线程文件路径"""
        return self.threads_path / f"{thread_id}.json"

    async def save(self, thread_data: Dict[str, Any]) -> bool:
        """保存线程数据"""
        thread_file = self._get_thread_file(thread_data["thread_id"])
        temp_file = thread_file.with_suffix(".tmp")
        
        try:
            # 创建临时文件
            with open(temp_file, 'w', encoding='utf-8') as f:
                json.dump(thread_data, f, ensure_ascii=False, indent=2)
            
            # 原子性替换
            temp_file.replace(thread_file)
            
            return True
        except Exception:
            # 清理临时文件
            try:
                if temp_file.exists():
                    temp_file.unlink()
            except Exception:
                pass
            return False

    async def find_by_id(self, thread_id: str) -> Optional[Dict[str, Any]]:
        """根据ID查找线程"""
        try:
            thread_file = self._get_thread_file(thread_id)
            if not thread_file.exists():
                return None
                
            with open(thread_file, 'r', encoding='utf-8') as f:
                return json.load(f)
        except Exception:
            return None

    async def delete(self, thread_id: str) -> bool:
        """删除线程"""
        try:
            thread_file = self._get_thread_file(thread_id)
            if thread_file.exists():
                thread_file.unlink()
            return True
        except Exception:
            return False

    async def find_all(self, filters: Optional[Dict[str, Any]] = None) -> List[Dict[str, Any]]:
        """查找所有线程"""
        threads = []
        
        try:
            for thread_file in self.threads_path.glob("*.json"):
                try:
                    with open(thread_file, 'r', encoding='utf-8') as f:
                        thread_data = json.load(f)
                    
                    # 应用过滤条件
                    if self._matches_filters(thread_data, filters):
                        threads.append(thread_data)
                        
                except Exception:
                    # 跳过损坏的文件
                    continue
                    
        except Exception:
            pass
            
        return threads

    async def exists(self, thread_id: str) -> bool:
        """检查线程是否存在"""
        thread_file = self._get_thread_file(thread_id)
        return thread_file.exists()

    def _matches_filters(self, thread_data: Dict[str, Any], filters: Optional[Dict[str, Any]]) -> bool:
        """检查线程数据是否匹配过滤条件"""
        if not filters:
            return True
        
        for key, value in filters.items():
            if key == "status":
                if thread_data.get("status") != value:
                    return False
            elif key == "graph_id":
                if thread_data.get("graph_id") != value:
                    return False
            elif key == "metadata":
                thread_metadata = thread_data.get("metadata", {})
                for meta_key, expected_value in value.items():
                    if thread_metadata.get(meta_key) != expected_value:
                        return False
        return True


class ThreadBranchRepository(IThreadBranchRepository):
    """线程分支仓储实现"""

    def __init__(self, storage_path: Path) -> None:
        """初始化线程分支仓储"""
        self.storage_path = storage_path
        self.branches_path = storage_path / "branches"
        self.branches_path.mkdir(parents=True, exist_ok=True)

    def _get_branch_file(self, branch_id: str) -> Path:
        """获取分支文件路径"""
        return self.branches_path / f"{branch_id}.json"

    async def save(self, branch_data: Dict[str, Any]) -> bool:
        """保存分支信息"""
        branch_file = self._get_branch_file(branch_data["branch_id"])
        try:
            with open(branch_file, 'w', encoding='utf-8') as f:
                json.dump(branch_data, f, ensure_ascii=False, indent=2)
            return True
        except Exception:
            return False

    async def find_by_id(self, branch_id: str) -> Optional[Dict[str, Any]]:
        """根据ID查找分支"""
        try:
            branch_file = self._get_branch_file(branch_id)
            if not branch_file.exists():
                return None
                
            with open(branch_file, 'r', encoding='utf-8') as f:
                return json.load(f)
        except Exception:
            return None

    async def find_by_thread(self, thread_id: str) -> List[Dict[str, Any]]:
        """查找线程的所有分支"""
        branches = []
        
        try:
            for branch_file in self.branches_path.glob("*.json"):
                try:
                    with open(branch_file, 'r', encoding='utf-8') as f:
                        branch_data = json.load(f)
                    
                    if branch_data.get("source_thread_id") == thread_id:
                        branches.append(branch_data)
                        
                except Exception:
                    continue
                    
        except Exception:
            pass
            
        return branches

    async def delete(self, branch_id: str) -> bool:
        """删除分支"""
        try:
            branch_file = self._get_branch_file(branch_id)
            if branch_file.exists():
                branch_file.unlink()
            return True
        except Exception:
            return False


class ThreadSnapshotRepository(IThreadSnapshotRepository):
    """线程快照仓储实现"""

    def __init__(self, storage_path: Path) -> None:
        """初始化线程快照仓储"""
        self.storage_path = storage_path
        self.snapshots_path = storage_path / "snapshots"
        self.snapshots_path.mkdir(parents=True, exist_ok=True)

    def _get_snapshot_file(self, snapshot_id: str) -> Path:
        """获取快照文件路径"""
        return self.snapshots_path / f"{snapshot_id}.json"

    async def save(self, snapshot_data: Dict[str, Any]) -> bool:
        """保存快照信息"""
        snapshot_file = self._get_snapshot_file(snapshot_data["snapshot_id"])
        try:
            with open(snapshot_file, 'w', encoding='utf-8') as f:
                json.dump(snapshot_data, f, ensure_ascii=False, indent=2)
            return True
        except Exception:
            return False

    async def find_by_id(self, snapshot_id: str) -> Optional[Dict[str, Any]]:
        """根据ID查找快照"""
        try:
            snapshot_file = self._get_snapshot_file(snapshot_id)
            if not snapshot_file.exists():
                return None
                
            with open(snapshot_file, 'r', encoding='utf-8') as f:
                return json.load(f)
        except Exception:
            return None

    async def find_by_thread(self, thread_id: str) -> List[Dict[str, Any]]:
        """查找线程的所有快照"""
        snapshots = []
        
        try:
            for snapshot_file in self.snapshots_path.glob("*.json"):
                try:
                    with open(snapshot_file, 'r', encoding='utf-8') as f:
                        snapshot_data = json.load(f)
                    
                    if snapshot_data.get("thread_id") == thread_id:
                        snapshots.append(snapshot_data)
                        
                except Exception:
                    continue
                    
        except Exception:
            pass
            
        return snapshots

    async def delete(self, snapshot_id: str) -> bool:
        """删除快照"""
        try:
            snapshot_file = self._get_snapshot_file(snapshot_id)
            if snapshot_file.exists():
                snapshot_file.unlink()
            return True
        except Exception:
            return False
```

## 迁移依赖关系调整

### 导入路径更新

**旧导入路径：**
```python
from src.domain.sessions.store import ISessionStore, FileSessionStore
from src.domain.threads.interfaces import IThreadRepository
from src.domain.threads.models import Thread
from src.domain.threads.domain_service import ThreadDomainService
```

**新导入路径：**
```python
from src.interfaces.sessions import ISessionStore
from src.interfaces.threads import IThreadRepository
from src.core.threads import Thread
from src.services.threads import ThreadDomainService
from src.adapters.storage import FileSessionStore
```

### 依赖注入配置

在依赖注入容器中注册新的服务：

```python
# src/services/container/container.py
from src.interfaces.sessions import ISessionStore, ISessionManager
from src.interfaces.threads import IThreadRepository, IThreadDomainService
from src.services.sessions import SessionManager
from src.services.threads import ThreadDomainService
from src.adapters.storage import FileSessionStore, ThreadRepository

# 注册会话相关服务
container.register_singleton(ISessionStore, FileSessionStore, storage_path=Path("./data/sessions"))
container.register_singleton(ISessionManager, SessionManager)

# 注册线程相关服务  
container.register_singleton(IThreadRepository, ThreadRepository, storage_path=Path("./data/threads"))
container.register_singleton(IThreadDomainService, ThreadDomainService)
```

## 迁移注意事项

### 1. 向后兼容性
在迁移期间，保持旧接口的兼容性，通过适配器模式桥接新旧接口：

```python
# 兼容性适配器
class LegacyThreadAdapter:
    """线程旧接口适配器"""
    
    def __init__(self, new_thread_service):
        self.new_thread_service = new_thread_service
    
    async def create_thread(self, graph_id: str, metadata=None):
        # 调用新接口，适配旧格式
        thread_data = await self.new_thread_service.create_thread(graph_id, metadata)
        return Thread.from_dict(thread_data)  # 转换回旧格式
```

### 2. 数据迁移
如果需要迁移现有数据，创建数据迁移工具：

```python
# 数据迁移工具
class DataMigrationTool:
    """数据迁移工具"""
    
    async def migrate_sessions(self, old_store, new_store):
        """迁移会话数据"""
        sessions = old_store.list_sessions()
        for session in sessions:
            # 转换数据格式
            new_format = self.convert_session_format(session)
            new_store.save_session(new_format["session_id"], new_format)
    
    def convert_session_format(self, old_session):
        """转换会话数据格式"""
        # 实现格式转换逻辑
        pass
```

### 3. 测试策略
- **单元测试**：确保每个新组件的功能正确
- **集成测试**：验证新旧组件之间的交互
- **回归测试**：确保现有功能不受影响

### 4. 性能考虑
- **懒加载**：避免在启动时加载所有数据
- **缓存机制**：在适当的地方添加缓存
- **异步操作**：充分利用异步IO提高性能

### 5. 错误处理
- **异常转换**：在新旧接口之间转换异常类型
- **错误恢复**：确保错误不会导致数据不一致
- **日志记录**：添加充分的日志便于调试

## 迁移验证清单

- [ ] 接口定义已迁移到 `src/interfaces/`
- [ ] 核心实体已迁移到 `src/core/`
- [ ] 服务实现已迁移到 `src/services/`
- [ ] 存储适配器已迁移到 `src/adapters/storage/`
- [ ] 所有导入路径已更新
- [ ] 依赖注入配置已更新
- [ ] 单元测试已通过
- [ ] 集成测试已通过
- [ ] 向后兼容性已验证
- [ ] 性能测试已通过
- [ ] 文档已更新

## 总结

这个迁移方案遵循了新架构的扁平化设计原则，将原有的domain层功能分散到interfaces、core、services和adapters四个层级中。通过这种方式，我们获得了更好的模块化和更低的耦合度，同时保持了系统的功能完整性。

迁移过程应该分步骤进行，确保每个阶段都有充分的测试验证，并在生产环境中采用渐进式部署策略。