# Sessions和Threads模块接口设计

## 设计原则

1. **接口隔离**：每个接口只负责单一职责
2. **依赖倒置**：高层模块依赖接口，不依赖具体实现
3. **最小暴露**：只暴露必要的接口方法
4. **类型安全**：使用Python类型提示确保接口契约
5. **异步支持**：支持异步操作以提高性能

## Sessions模块接口设计

### 1. 存储层接口 (ISessionStore)

**位置**: `src/interfaces/sessions/interfaces.py`

```python
from abc import ABC, abstractmethod
from typing import Dict, Any, Optional, List


class ISessionStore(ABC):
    """会话存储接口 - 负责会话数据的持久化"""

    @abstractmethod
    def save_session(self, session_id: str, session_data: Dict[str, Any]) -> bool:
        """保存会话数据
        
        Args:
            session_id: 会话唯一标识
            session_data: 会话数据字典
            
        Returns:
            保存成功返回True，失败返回False
            
        Raises:
            SessionStoreException: 存储操作失败时抛出
        """
        pass

    @abstractmethod
    def get_session(self, session_id: str) -> Optional[Dict[str, Any]]:
        """获取会话数据
        
        Args:
            session_id: 会话唯一标识
            
        Returns:
            会话数据字典，不存在时返回None
        """
        pass

    @abstractmethod
    def delete_session(self, session_id: str) -> bool:
        """删除会话数据
        
        Args:
            session_id: 会话唯一标识
            
        Returns:
            删除成功返回True，失败返回False
        """
        pass

    @abstractmethod
    def list_sessions(self) -> List[Dict[str, Any]]:
        """列出所有会话
        
        Returns:
            会话列表，每个元素是会话基本信息的字典
        """
        pass

    @abstractmethod
    def session_exists(self, session_id: str) -> bool:
        """检查会话是否存在
        
        Args:
            session_id: 会话唯一标识
            
        Returns:
            存在返回True，不存在返回False
        """
        pass
```

### 2. 管理层接口 (ISessionManager)

**位置**: `src/interfaces/sessions/base.py`

```python
from abc import ABC, abstractmethod
from typing import Dict, Any, Optional, List


class ISessionManager(ABC):
    """会话管理器接口 - 负责会话的生命周期管理"""

    @abstractmethod
    async def create_session(self, workflow_config_path: str, metadata: Optional[Dict[str, Any]] = None) -> str:
        """创建新会话
        
        Args:
            workflow_config_path: 工作流配置文件路径
            metadata: 可选的会话元数据
            
        Returns:
            新创建的会话ID
            
        Raises:
            SessionCreationException: 创建失败时抛出
        """
        pass

    @abstractmethod
    async def get_session(self, session_id: str) -> Optional[Dict[str, Any]]:
        """获取会话详细信息
        
        Args:
            session_id: 会话唯一标识
            
        Returns:
            会话详细信息字典，不存在时返回None
        """
        pass

    @abstractmethod
    async def delete_session(self, session_id: str) -> bool:
        """删除会话
        
        Args:
            session_id: 会话唯一标识
            
        Returns:
            删除成功返回True，失败返回False
            
        Raises:
            SessionDeletionException: 删除失败时抛出
        """
        pass

    @abstractmethod
    async def list_sessions(self, filters: Optional[Dict[str, Any]] = None) -> List[Dict[str, Any]]:
        """列出会话
        
        Args:
            filters: 可选的过滤条件
            
        Returns:
            会话列表
        """
        pass

    @abstractmethod
    async def update_session_status(self, session_id: str, status: str) -> bool:
        """更新会话状态
        
        Args:
            session_id: 会话唯一标识
            status: 新状态
            
        Returns:
            更新成功返回True，失败返回False
        """
        pass
```

### 3. 核心层接口 (ISessionCore)

**位置**: `src/core/sessions/interfaces.py`

```python
from abc import ABC, abstractmethod
from typing import Dict, Any, Optional
from .entities import Session


class ISessionCore(ABC):
    """会话核心接口 - 定义会话的核心业务逻辑"""

    @abstractmethod
    def create_session(self, workflow_config_path: str, metadata: Optional[Dict[str, Any]] = None) -> Session:
        """创建会话实体
        
        Args:
            workflow_config_path: 工作流配置文件路径
            metadata: 可选的会话元数据
            
        Returns:
            新创建的会话实体
        """
        pass

    @abstractmethod
    def validate_session_state(self, session: Session) -> bool:
        """验证会话状态
        
        Args:
            session: 会话实体
            
        Returns:
            状态有效返回True，无效返回False
        """
        pass

    @abstractmethod
    def can_transition_to_status(self, session: Session, new_status: str) -> bool:
        """检查是否可以转换到指定状态
        
        Args:
            session: 当前会话
            new_status: 目标状态
            
        Returns:
            可以转换返回True，否则返回False
        """
        pass
```

## Threads模块接口设计

### 1. 仓储层接口

#### IThreadRepository

**位置**: `src/interfaces/threads/interfaces.py`

```python
from abc import ABC, abstractmethod
from typing import Dict, Any, Optional, List


class IThreadRepository(ABC):
    """线程仓储接口 - 负责线程数据的持久化"""

    @abstractmethod
    async def save(self, thread_data: Dict[str, Any]) -> bool:
        """保存线程数据
        
        Args:
            thread_data: 线程数据字典
            
        Returns:
            保存成功返回True，失败返回False
        """
        pass

    @abstractmethod
    async def find_by_id(self, thread_id: str) -> Optional[Dict[str, Any]]:
        """根据ID查找线程
        
        Args:
            thread_id: 线程唯一标识
            
        Returns:
            线程数据字典，不存在时返回None
        """
        pass

    @abstractmethod
    async def delete(self, thread_id: str) -> bool:
        """删除线程
        
        Args:
            thread_id: 线程唯一标识
            
        Returns:
            删除成功返回True，失败返回False
        """
        pass

    @abstractmethod
    async def find_all(self, filters: Optional[Dict[str, Any]] = None) -> List[Dict[str, Any]]:
        """查找所有线程
        
        Args:
            filters: 可选的过滤条件
            
        Returns:
            线程列表
        """
        pass

    @abstractmethod
    async def exists(self, thread_id: str) -> bool:
        """检查线程是否存在
        
        Args:
            thread_id: 线程唯一标识
            
        Returns:
            存在返回True，不存在返回False
        """
        pass

    @abstractmethod
    async def update_status(self, thread_id: str, status: str) -> bool:
        """更新线程状态
        
        Args:
            thread_id: 线程唯一标识
            status: 新状态
            
        Returns:
            更新成功返回True，失败返回False
        """
        pass
```

#### IThreadBranchRepository

```python
class IThreadBranchRepository(ABC):
    """线程分支仓储接口"""

    @abstractmethod
    async def save(self, branch_data: Dict[str, Any]) -> bool:
        """保存分支信息"""
        pass

    @abstractmethod
    async def find_by_id(self, branch_id: str) -> Optional[Dict[str, Any]]:
        """根据ID查找分支"""
        pass

    @abstractmethod
    async def find_by_thread(self, thread_id: str) -> List[Dict[str, Any]]:
        """查找线程的所有分支"""
        pass

    @abstractmethod
    async def delete(self, branch_id: str) -> bool:
        """删除分支"""
        pass

    @abstractmethod
    async def find_active_branches(self, thread_id: str) -> List[Dict[str, Any]]:
        """查找线程的所有活跃分支"""
        pass
```

#### IThreadSnapshotRepository

```python
class IThreadSnapshotRepository(ABC):
    """线程快照仓储接口"""

    @abstractmethod
    async def save(self, snapshot_data: Dict[str, Any]) -> bool:
        """保存快照信息"""
        pass

    @abstractmethod
    async def find_by_id(self, snapshot_id: str) -> Optional[Dict[str, Any]]:
        """根据ID查找快照"""
        pass

    @abstractmethod
    async def find_by_thread(self, thread_id: str) -> List[Dict[str, Any]]:
        """查找线程的所有快照"""
        pass

    @abstractmethod
    async def delete(self, snapshot_id: str) -> bool:
        """删除快照"""
        pass

    @abstractmethod
    async def find_latest_snapshot(self, thread_id: str) -> Optional[Dict[str, Any]]:
        """查找线程的最新快照"""
        pass
```

### 2. 领域服务接口 (IThreadDomainService)

```python
class IThreadDomainService(ABC):
    """线程领域服务接口 - 负责线程的核心业务逻辑"""

    @abstractmethod
    async def create_thread(self, graph_id: str, metadata: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """创建新线程
        
        Args:
            graph_id: 图ID
            metadata: 可选的线程元数据
            
        Returns:
            新创建的线程数据
        """
        pass

    @abstractmethod
    async def create_thread_from_config(self, config_path: str, metadata: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """从配置文件创建线程
        
        Args:
            config_path: 配置文件路径
            metadata: 可选的线程元数据
            
        Returns:
            新创建的线程数据
        """
        pass

    @abstractmethod
    async def fork_thread(self, source_thread_id: str, checkpoint_id: str, branch_name: str, metadata: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """创建线程分支
        
        Args:
            source_thread_id: 源线程ID
            checkpoint_id: 检查点ID
            branch_name: 分支名称
            metadata: 可选的分支元数据
            
        Returns:
            新创建的分支线程数据
        """
        pass

    @abstractmethod
    async def validate_thread_state(self, thread_id: str, state: Dict[str, Any]) -> bool:
        """验证线程状态
        
        Args:
            thread_id: 线程ID
            state: 状态数据
            
        Returns:
            状态有效返回True，无效返回False
        """
        pass

    @abstractmethod
    async def can_transition_to_status(self, thread_id: str, current_status: str, new_status: str) -> bool:
        """检查是否可以转换到指定状态
        
        Args:
            thread_id: 线程ID
            current_status: 当前状态
            new_status: 目标状态
            
        Returns:
            可以转换返回True，否则返回False
        """
        pass

    @abstractmethod
    async def merge_thread(self, source_thread_id: str, target_thread_id: str, merge_strategy: str = "overwrite") -> bool:
        """合并线程
        
        Args:
            source_thread_id: 源线程ID
            target_thread_id: 目标线程ID
            merge_strategy: 合并策略
            
        Returns:
            合并成功返回True，失败返回False
        """
        pass
```

### 3. 管理层接口 (IThreadManager)

**位置**: `src/interfaces/threads/base.py`

```python
class IThreadManager(ABC):
    """线程管理器接口 - 负责线程的生命周期管理"""

    @abstractmethod
    async def create_thread(self, graph_id: str, metadata: Optional[Dict[str, Any]] = None) -> str:
        """创建新线程"""
        pass

    @abstractmethod
    async def get_thread(self, thread_id: str) -> Optional[Dict[str, Any]]:
        """获取线程信息"""
        pass

    @abstractmethod
    async def delete_thread(self, thread_id: str) -> bool:
        """删除线程"""
        pass

    @abstractmethod
    async def list_threads(self, filters: Optional[Dict[str, Any]] = None) -> List[Dict[str, Any]]:
        """列出线程"""
        pass

    @abstractmethod
    async def fork_thread(self, source_thread_id: str, checkpoint_id: str, branch_name: str) -> str:
        """创建线程分支"""
        pass

    @abstractmethod
    async def create_snapshot(self, thread_id: str, snapshot_name: str, description: Optional[str] = None) -> str:
        """创建线程快照"""
        pass

    @abstractmethod
    async def restore_snapshot(self, thread_id: str, snapshot_id: str) -> bool:
        """恢复线程快照"""
        pass
```

### 4. 协调器接口 (IThreadCoordinator)

**位置**: `src/interfaces/threads/coordination.py`

```python
class IThreadCoordinator(ABC):
    """线程协调器接口 - 负责线程间的协调和同步"""

    @abstractmethod
    async def coordinate_threads(self, thread_ids: List[str], coordination_strategy: str) -> Dict[str, Any]:
        """协调多个线程
        
        Args:
            thread_ids: 线程ID列表
            coordination_strategy: 协调策略
            
        Returns:
            协调结果
        """
        pass

    @abstractmethod
    async def synchronize_threads(self, source_thread_id: str, target_thread_ids: List[str], sync_config: Dict[str, Any]) -> bool:
        """同步线程状态
        
        Args:
            source_thread_id: 源线程ID
            target_thread_ids: 目标线程ID列表
            sync_config: 同步配置
            
        Returns:
            同步成功返回True，失败返回False
        """
        pass

    @abstractmethod
    async def resolve_conflicts(self, thread_id: str, conflicts: List[Dict[str, Any]]) -> Dict[str, Any]:
        """解决线程冲突
        
        Args:
            thread_id: 线程ID
            conflicts: 冲突列表
            
        Returns:
            冲突解决结果
        """
        pass
```

### 5. 分支管理接口 (IThreadBranchingService)

```python
class IThreadBranchingService(ABC):
    """线程分支服务接口 - 负责线程分支的管理"""

    @abstractmethod
    async def create_branch(self, thread_id: str, branch_name: str, source_checkpoint_id: str) -> str:
        """创建分支"""
        pass

    @abstractmethod
    async def merge_branch(self, branch_id: str, target_thread_id: str, merge_strategy: str = "overwrite") -> bool:
        """合并分支"""
        pass

    @abstractmethod
    async def switch_branch(self, thread_id: str, branch_id: str) -> bool:
        """切换分支"""
        pass

    @abstractmethod
    async def list_branches(self, thread_id: str) -> List[Dict[str, Any]]:
        """列出分支"""
        pass

    @abstractmethod
    async def delete_branch(self, branch_id: str) -> bool:
        """删除分支"""
        pass
```

## 协作接口设计

### 1. 协作服务接口 (IThreadCollaborationService)

**位置**: `src/interfaces/threads/collaboration.py`

```python
from abc import ABC, abstractmethod
from typing import Dict, Any, Optional, List


class IThreadCollaborationService(ABC):
    """线程协作服务接口 - 负责线程间的协作管理"""

    @abstractmethod
    async def create_collaboration(self, collaboration_config: Dict[str, Any]) -> str:
        """创建协作
        
        Args:
            collaboration_config: 协作配置
            
        Returns:
            协作ID
        """
        pass

    @abstractmethod
    async def join_collaboration(self, collaboration_id: str, thread_id: str, role: str) -> bool:
        """加入协作
        
        Args:
            collaboration_id: 协作ID
            thread_id: 线程ID
            role: 角色
            
        Returns:
            加入成功返回True，失败返回False
        """
        pass

    @abstractmethod
    async def leave_collaboration(self, collaboration_id: str, thread_id: str) -> bool:
        """离开协作
        
        Args:
            collaboration_id: 协作ID
            thread_id: 线程ID
            
        Returns:
            离开成功返回True，失败返回False
        """
        pass

    @abstractmethod
    async def share_thread_state(self, collaboration_id: str, thread_id: str, shared_state: Dict[str, Any]) -> bool:
        """共享线程状态
        
        Args:
            collaboration_id: 协作ID
            thread_id: 线程ID
            shared_state: 共享的状态数据
            
        Returns:
            共享成功返回True，失败返回False
        """
        pass

    @abstractmethod
    async def get_shared_states(self, collaboration_id: str) -> Dict[str, Any]:
        """获取共享状态
        
        Args:
            collaboration_id: 协作ID
            
        Returns:
            共享状态字典
        """
        pass

    @abstractmethod
    async def resolve_collaboration_conflicts(self, collaboration_id: str, conflicts: List[Dict[str, Any]]) -> Dict[str, Any]:
        """解决协作冲突
        
        Args:
            collaboration_id: 协作ID
            conflicts: 冲突列表
            
        Returns:
            冲突解决结果
        """
        pass
```

## 异常定义

### Sessions模块异常

**位置**: `src/core/sessions/exceptions.py`

```python
class SessionException(Exception):
    """会话基础异常"""
    pass


class SessionNotFoundException(SessionException):
    """会话未找到异常"""
    pass


class SessionCreationException(SessionException):
    """会话创建异常"""
    pass


class SessionDeletionException(SessionException):
    """会话删除异常"""
    pass


class SessionStoreException(SessionException):
    """会话存储异常"""
    pass


class InvalidSessionStateException(SessionException):
    """无效的会话状态异常"""
    pass
```

### Threads模块异常

**位置**: `src/core/threads/exceptions.py`

```python
class ThreadException(Exception):
    """线程基础异常"""
    pass


class ThreadNotFoundException(ThreadException):
    """线程未找到异常"""
    pass


class ThreadCreationException(ThreadException):
    """线程创建异常"""
    pass


class ThreadDeletionException(ThreadException):
    """线程删除异常"""
    pass


class ThreadRepositoryException(ThreadException):
    """线程仓储异常"""
    pass


class InvalidThreadStateException(ThreadException):
    """无效的线程状态异常"""
    pass


class ThreadBranchException(ThreadException):
    """线程分支异常"""
    pass


class ThreadSnapshotException(ThreadException):
    """线程快照异常"""
    pass


class ThreadCollaborationException(ThreadException):
    """线程协作异常"""
    pass


class ThreadConflictException(ThreadException):
    """线程冲突异常"""
    pass
```

## 接口使用示例

### Sessions模块使用示例

```python
# 使用会话管理器
from src.interfaces.sessions import ISessionManager
from src.services.container import container

# 获取会话管理器实例
session_manager = container.get(ISessionManager)

# 创建会话
session_id = await session_manager.create_session(
    workflow_config_path="configs/workflows/react.yaml",
    metadata={"user_id": "user123", "project_id": "proj456"}
)

# 获取会话信息
session_info = await session_manager.get_session(session_id)

# 更新会话状态
success = await session_manager.update_session_status(session_id, "running")

# 列出会话
sessions = await session_manager.list_sessions(filters={"status": "active"})

# 删除会话
success = await session_manager.delete_session(session_id)
```

### Threads模块使用示例

```python
# 使用线程领域服务
from src.interfaces.threads import IThreadDomainService
from src.services.container import container

# 获取线程领域服务实例
thread_service = container.get(IThreadDomainService)

# 创建线程
thread_data = await thread_service.create_thread(
    graph_id="graph_123",
    metadata={"description": "测试线程"}
)

# 创建线程分支
branch_data = await thread_service.fork_thread(
    source_thread_id=thread_data["thread_id"],
    checkpoint_id="checkpoint_456", 
    branch_name="feature-branch",
    metadata={"description": "功能分支"}
)

# 验证线程状态
is_valid = await thread_service.validate_thread_state(
    thread_id=thread_data["thread_id"],
    state={"current_node": "node_1", "status": "running"}
)

# 使用线程管理器
from src.interfaces.threads import IThreadManager

thread_manager = container.get(IThreadManager)

# 创建快照
snapshot_id = await thread_manager.create_snapshot(
    thread_id=thread_data["thread_id"],
    snapshot_name="checkpoint-1",
    description="第一个检查点"
)

# 恢复快照
success = await thread_manager.restore_snapshot(
    thread_id=thread_data["thread_id"],
    snapshot_id=snapshot_id
)
```

## 接口版本管理

为了支持接口的演进，采用版本化的接口设计：

```python
# 接口版本管理
class IThreadRepositoryV1(IThreadRepository):
    """线程仓储接口V1版本"""
    pass


class IThreadRepositoryV2(IThreadRepository):
    """线程仓储接口V2版本 - 添加了新方法"""
    
    @abstractmethod
    async def bulk_save(self, thread_data_list: List[Dict[str, Any]]) -> bool:
        """批量保存线程数据"""
        pass

    @abstractmethod
    async def search_threads(self, query: str, filters: Optional[Dict[str, Any]] = None) -> List[Dict[str, Any]]:
        """搜索线程"""
        pass
```

## 总结

这个接口设计遵循了以下原则：

1. **单一职责**：每个接口只负责特定的功能领域
2. **接口隔离**：客户端只需要依赖它们需要的接口
3. **依赖倒置**：高层模块依赖抽象接口，不依赖具体实现
4. **可扩展性**：通过版本管理和继承支持接口演进
5. **类型安全**：使用Python类型提示确保编译时检查
6. **异步支持**：充分利用异步编程模型提高性能

通过集中管理接口定义，我们避免了循环导入问题，同时提供了清晰的模块边界和职责分离。