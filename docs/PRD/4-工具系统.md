# 文档4：工具系统需求文档
## 1. 文档标识
- 模块名称：工具系统
- 版本：V1.0
- 依赖模块：基础架构与环境配置、配置系统、模型集成

## 2. 模块目标
实现工具的统一管理（发现、加载、调用），支持多类型工具（原生能力、MCP、内置函数），提供灵活的输出格式化策略与工具集组合，确保Agent能安全、高效地使用工具。

## 3. 技术栈
- 核心库：langchain（工具定义）、requests（MCP服务通信）
- 序列化：pydantic（工具Schema定义）
- 并发：asyncio（并行工具调用）

## 4. 功能性需求
### 4.1 工具类型与实现
#### 4.1.1 工具分类与定义
- 支持3类工具，统一继承`BaseTool`（LangChain）：
  1. **原生能力工具**：API供应商内置能力（如`SearchTool`，调用搜索引擎API）
     - 实现：`NativeTool`，配置包含`api_url`、`auth_method`（如API Key）
  2. **MCP工具**：外部MCP服务器提供的工具
     - 实现：`MCPTool`，通过`mcp_server_url`获取工具Schema，调用`/execute`接口执行
  3. **内置工具**：项目内部Python函数
     - 实现：`BuiltinTool`，通过`@tool`装饰器注册函数（如`def calculate(a: int, b: int) -> int`）
- 所有工具需定义Schema（Pydantic模型）：包含`name`（工具名）、`description`（功能描述）、`parameters`（参数列表，含类型、是否必填）

#### 4.1.2 工具加载与管理
- 实现`ToolManager`：负责工具的发现、加载、注册
  - 加载路径：`tools/native/`（原生）、`tools/builtin/`（内置）、`tools/mcp/`（MCP配置）
  - 自动发现：扫描指定路径下的工具定义，无需手动注册
- 工具去重：加载时检测重复工具（按`name`判断），给出警告，保留配置中靠前的工具，后续重复工具仅记录引用

### 4.2 工具集管理
- 支持“工具集”概念：将多个工具组合为工具集（如`data_analysis_set: [sql_tool, excel_tool, plot_tool]`）
- 工具集配置：在`configs/tool_sets/`下定义YAML文件，如：
  ```yaml
  name: data_analysis_set
  description: 数据分析工具集
  tools:
    - sql_tool
    - excel_tool
    - plot_tool
  ```
- Agent配置中可引用工具集（`tool_sets: [data_analysis_set]`）或单独工具（`tools: [search_tool]`），最终合并为可用工具列表

### 4.3 输出格式化策略
#### 4.3.1 策略配置
- 支持2种输出格式化策略，通过Agent配置控制：
  ```yaml
  output_strategy:
    function_calling: true  # 优先使用模型原生Function Calling
    fallback_to_structured_output: true  # 失败时降级为LangChain结构化输出
  ```
- 策略探测：`ToolFormatter`在调用前检测模型是否支持Function Calling（通过`ILLMClient`的`supports_function_calling()`方法）
  - 探测成功：使用原生Function Calling（按模型要求格式生成工具调用）
  - 探测失败：若允许降级，使用LangChain结构化输出（基于Pydantic+提示词引导）；否则报错退出

#### 4.3.2 格式生成
- 原生Function Calling：生成符合模型要求的格式（如OpenAI的`function_call`字段）
- 结构化输出：生成提示词模板（包含工具Schema），引导LLM输出JSON格式，如：
  ```
  请按以下格式调用工具：
  {
    "name": "工具名",
    "parameters": {
      "参数1": "值1",
      "参数2": "值2"
    }
  }
  ```

### 4.4 工具调用执行
- 实现`ToolExecutor`：负责工具调用的执行与结果处理
  - 同步/异步支持：内置工具同步执行，原生/MCP工具支持异步（`async_execute()`）
  - 并行调用：支持多工具并行执行（基于LangGraph原生并行能力，通过`parallel=True`配置）
  - 结果封装：将工具输出封装为`ToolMessage`（包含`tool_name`、`output`、`error`字段），传入`AgentState`

### 4.5 工具调用安全
- 参数校验：调用前校验工具参数（类型、必填项），无效参数时返回`invalid_parameters`错误
- 超时控制：工具调用超时配置（`timeout: 30s`），超时后返回`timeout`错误
- 权限控制：MCP工具支持API Key认证（配置`mcp_api_key`），调用时传入标头

## 5. 非功能性需求
- **可扩展性**：新增工具时只需实现`BaseTool`并放入指定路径，无需修改核心逻辑
- **可靠性**：工具调用失败时返回明确错误信息（如参数错误、超时），不崩溃
- **可观测性**：工具调用的参数、结果、耗时通过`ILogger`记录（INFO级别）

## 6. 依赖接口
- `IConfigLoader`（基础架构模块）：加载工具/工具集配置
- `IConfigSystem`（配置系统模块）：处理Agent的工具引用与合并
- `ILLMClient`（模型集成模块）：探测模型是否支持Function Calling
- `IMetricsCollector`（日志与指标模块）：记录工具调用耗时、成功率

## 7. 提供接口
- `IToolManager`：工具管理接口（`load_tools() -> list[BaseTool]`、`get_tool(name: str) -> BaseTool`、`get_tool_set(name: str) -> list[BaseTool]`）
- `IToolFormatter`：格式化为接口（`format(tool: BaseTool, parameters: dict) -> dict`、`detect_strategy(llm_client: ILLMClient) -> str`）
- `IToolExecutor`：执行接口（`execute(tool: BaseTool, parameters: dict) -> ToolMessage`、`async_execute(tool: BaseTool, parameters: dict) -> ToolMessage`）

## 8. 测试要点
- 工具加载测试：去重逻辑、MCP工具发现
- 输出策略测试：原生Function Calling、降级结构化输出的正确性
- 并行调用测试：多工具同时调用的结果合并
- 错误处理测试：参数错误、超时、权限不足场景的处理
