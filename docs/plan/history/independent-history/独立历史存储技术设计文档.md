# 独立历史存储技术设计文档

## 1. 现有架构分析

### 1.1 当前架构模式
基于对现有代码的分析，项目采用以下架构模式：
- **分层架构**: Domain → Application → Infrastructure → Presentation
- **依赖注入**: 使用 [`DependencyContainer`](src/infrastructure/container.py:74) 管理服务生命周期
- **接口驱动**: 大量使用抽象接口（如 [`ISessionManager`](src/application/sessions/manager.py:21)、[`ISessionStore`](src/domain/sessions/store.py:14)）
- **配置驱动**: YAML配置文件系统，支持环境变量注入和热重载

### 1.2 当前历史存储问题
- **TUI耦合**: [`StateManager`](src/presentation/tui/state_manager.py:8) 直接管理消息历史
- **存储限制**: [`FileSessionStore`](src/domain/sessions/store.py:76) 仅支持基本会话数据
- **查询能力弱**: 缺乏专门的索引和查询机制
- **扩展性差**: 难以支持新的历史记录类型

## 2. 核心架构设计

### 2.1 整体架构图

```mermaid
graph TB
    subgraph "Presentation Layer"
        TUI[TUI界面]
        CLI[CLI工具]
        API[Web API]
    end
    
    subgraph "Application Layer"
        HA[HistoryAdapter]
        HM[HistoryManager]
        HQ[HistoryQuery]
    end
    
    subgraph "Domain Layer"
        HI[IHistoryStorage]
        HI2[IHistoryIndex]
        HR[HistoryRecord]
        HQI[HistoryQueryInterface]
    end
    
    subgraph "Infrastructure Layer"
        FHS[FileHistoryStorage]
        SHS[SQLiteHistoryStorage]
        HIX[HistoryIndexManager]
        HCF[HistoryConfig]
    end
    
    TUI --> HA
    CLI --> HA
    API --> HA
    HA --> HM
    HM --> HI
    HM --> HI2
    HM --> HQ
    HI --> FHS
    HI --> SHS
    HI2 --> HIX
    HCF --> HM
```

## 3. 数据模型和记录结构

### 3.1 基础记录模型
```python
@dataclass
class HistoryRecord:
    """历史记录基类"""
    record_id: str
    session_id: str
    timestamp: datetime
    record_type: str
    metadata: Dict[str, Any]
    
    def to_dict(self) -> Dict[str, Any]:
        """转换为字典"""
        return asdict(self)
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'HistoryRecord':
        """从字典创建"""
        # 子类实现具体逻辑
        pass

@dataclass
class MessageRecord(HistoryRecord):
    """消息记录"""
    message_type: MessageType  # user, assistant, system
    content: str
    token_count: Optional[int] = None
    model_name: Optional[str] = None
    parent_message_id: Optional[str] = None
    response_time_ms: Optional[int] = None

@dataclass
class ToolCallRecord(HistoryRecord):
    """工具调用记录"""
    tool_name: str
    tool_type: str  # native, mcp, builtin
    parameters: Dict[str, Any]
    result: Any
    success: bool
    error: Optional[str] = None
    duration_ms: int = 0
    related_message_id: Optional[str] = None

@dataclass
class LLMRequestRecord(HistoryRecord):
    """LLM请求记录"""
    model_name: str
    request_payload: Dict[str, Any]
    response_payload: Dict[str, Any]
    request_time_ms: int
    token_usage: Dict[str, int]  # prompt, completion, total
    cost_estimate: Optional[float] = None
    error: Optional[str] = None

@dataclass
class WorkflowEventRecord(HistoryRecord):
    """工作流事件记录"""
    event_type: WorkflowEventType  # node_start, node_end, error, etc.
    node_id: Optional[str] = None
    node_type: Optional[str] = None
    event_data: Dict[str, Any] = field(default_factory=dict)
```

### 3.2 查询模型
```python
@dataclass
class HistoryQuery:
    """历史查询"""
    session_id: Optional[str] = None
    record_types: Optional[List[str]] = None
    start_time: Optional[datetime] = None
    end_time: Optional[datetime] = None
    keywords: Optional[List[str]] = None
    limit: int = 100
    offset: int = 0
    order_by: str = "timestamp"
    order_desc: bool = True

@dataclass
class SearchQuery:
    """搜索查询"""
    query: str
    session_id: Optional[str] = None
    record_types: Optional[List[str]] = None
    fuzzy: bool = True
    limit: int = 50

@dataclass
class SearchResult:
    """搜索结果"""
    record: HistoryRecord
    score: float
    highlights: List[str]
```

## 4. 存储后端实现策略

### 4.1 文件存储后端
```python
class FileHistoryStorage(IHistoryStorage):
    """基于文件的历史存储"""
    
    def __init__(self, base_path: Path, config: FileStorageConfig):
        self.base_path = base_path
        self.config = config
        self._session_files: Dict[str, Path] = {}
        self._lock = threading.RLock()
        
        # 创建目录结构
        self.base_path.mkdir(parents=True, exist_ok=True)
        (self.base_path / "sessions").mkdir(exist_ok=True)
        (self.base_path / "indexes").mkdir(exist_ok=True)
        (self.base_path / "backups").mkdir(exist_ok=True)
    
    def _get_session_file(self, session_id: str) -> Path:
        """获取会话文件路径"""
        if session_id not in self._session_files:
            # 按日期分组存储
            date_prefix = datetime.now().strftime("%Y%m")
            session_dir = self.base_path / "sessions" / date_prefix
            session_dir.mkdir(exist_ok=True)
            self._session_files[session_id] = session_dir / f"{session_id}.jsonl"
        return self._session_files[session_id]
    
    def store_record(self, record: HistoryRecord) -> bool:
        """存储记录"""
        try:
            with self._lock:
                session_file = self._get_session_file(record.session_id)
                
                # 追加写入JSONL格式
                with open(session_file, 'a', encoding='utf-8') as f:
                    json.dump(record.to_dict(), f, ensure_ascii=False, default=str)
                    f.write('\n')
                
                # 定期压缩旧文件
                if self.config.auto_compress and self._should_compress(session_file):
                    self._compress_file(session_file)
                
                return True
        except Exception as e:
            raise HistoryStorageError(f"存储记录失败: {e}")
```

### 4.2 SQLite存储后端
```python
class SQLiteHistoryStorage(IHistoryStorage):
    """基于SQLite的历史存储"""
    
    def __init__(self, db_path: Path, config: SQLiteStorageConfig):
        self.db_path = db_path
        self.config = config
        self._connection_pool = sqlite3.connect(str(db_path), check_same_thread=False)
        self._lock = threading.RLock()
        
        # 初始化数据库
        self._init_database()
    
    def _init_database(self):
        """初始化数据库表"""
        with self._lock:
            cursor = self._connection_pool.cursor()
            
            # 创建主记录表
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS history_records (
                    record_id TEXT PRIMARY KEY,
                    session_id TEXT NOT NULL,
                    timestamp DATETIME NOT NULL,
                    record_type TEXT NOT NULL,
                    data JSON NOT NULL,
                    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
                )
            ''')
            
            # 创建索引
            cursor.execute('''
                CREATE INDEX IF NOT EXISTS idx_session_timestamp 
                ON history_records(session_id, timestamp)
            ''')
            
            cursor.execute('''
                CREATE INDEX IF NOT EXISTS idx_record_type 
                ON history_records(record_type)
            ''')
            
            # 创建全文搜索表
            if self.config.enable_fts:
                cursor.execute('''
                    CREATE VIRTUAL TABLE IF NOT EXISTS history_fts 
                    USING fts5(record_id, content, session_id, record_type)
                ''')
            
            self._connection_pool.commit()
```

## 5. 索引和查询系统

### 5.1 索引管理器
```python
class HistoryIndexManager(IHistoryIndex):
    """历史索引管理器"""
    
    def __init__(self, index_path: Path, config: IndexConfig):
        self.index_path = index_path
        self.config = config
        self._message_index = whoosh.index.open_dir(
            str(index_path / "messages"), 
            schema=self._get_message_schema()
        ) if (index_path / "messages").exists() else self._create_message_index()
        
        self._tool_index = whoosh.index.open_dir(
            str(index_path / "tools"),
            schema=self._get_tool_schema()
        ) if (index_path / "tools").exists() else self._create_tool_index()
    
    def _get_message_schema(self) -> whoosh.fields.Schema:
        """获取消息索引模式"""
        return whoosh.fields.Schema(
            record_id=whoosh.fields.ID(stored=True),
            session_id=whoosh.fields.ID(stored=True),
            content=whoosh.fields.TEXT(stored=True, analyzer=whoosh.analysis.StemmingAnalyzer()),
            message_type=whoosh.fields.ID(stored=True),
            timestamp=whoosh.fields.DATETIME(stored=True),
            model_name=whoosh.fields.ID(stored=True)
        )
```

## 6. 文件结构和目录组织

### 6.1 模块目录结构
```
src/
├── domain/
│   └── history/
│       ├── __init__.py
│       ├── models.py              # 数据模型
│       ├── interfaces.py          # 接口定义
│       └── exceptions.py          # 异常定义
├── application/
│   └── history/
│       ├── __init__.py
│       ├── manager.py             # HistoryManager
│       ├── query.py               # 查询处理器
│       ├── adapters/
│       │   ├── __init__.py
│       │   ├── tui_adapter.py     # TUI适配器
│       │   └── cli_adapter.py     # CLI适配器
│       └── services/
│           ├── __init__.py
│           ├── export_service.py  # 导出服务
│           └── analytics_service.py # 分析服务
├── infrastructure/
│   └── history/
│       ├── __init__.py
│       ├── storage/
│       │   ├── __init__.py
│       │   ├── file_storage.py    # 文件存储
│       │   ├── sqlite_storage.py  # SQLite存储
│       │   └── storage_factory.py # 存储工厂
│       ├── index/
│       │   ├── __init__.py
│       │   ├── whoosh_index.py    # Whoosh全文索引
│       │   └── memory_index.py    # 内存索引
│       └── config/
│           ├── __init__.py
│           └── history_config.py  # 配置模型
└── presentation/
    └── history/
        ├── __init__.py
        └── components/            # UI组件（可选）
            └── history_viewer.py
```

### 6.2 数据存储结构
```
history/
├── sessions/                     # 会话数据
│   ├── 202410/                  # 按月分组
│   │   ├── session-1.jsonl
│   │   └── session-2.jsonl
│   └── 202411/
│       └── session-3.jsonl
├── indexes/                     # 索引文件
│   ├── messages/
│   │   ├── _main.toc
│   │   ├── segments_000
│   │   └── ...
│   └── tools/
│       └── ...
├── database/                    # SQLite数据库（可选）
│   └── history.db
├── backups/                     # 备份文件
│   ├── 20241001_backup.tar.gz
│   └── 20241101_backup.tar.gz
└── config/                      # 配置文件
    └── history.yaml
```

## 7. 与TUI的集成适配器

### 7.1 TUI适配器设计
```python
class TUIHistoryAdapter:
    """TUI历史适配器"""
    
    def __init__(self, history_manager: IHistoryManager, state_manager: StateManager):
        self.history_manager = history_manager
        self.state_manager = state_manager
        self._recording_enabled = True
    
    def on_user_message(self, content: str) -> None:
        """处理用户消息"""
        if not self._recording_enabled or not self.state_manager.session_id:
            return
        
        record = MessageRecord(
            record_id=str(uuid.uuid4()),
            session_id=self.state_manager.session_id,
            timestamp=datetime.now(),
            record_type="message",
            message_type=MessageType.USER,
            content=content,
            metadata={}
        )
        
        self.history_manager.record_message(record)
```

## 8. 配置系统集成方案

### 8.1 历史配置模型
```python
@dataclass
class HistoryConfig:
    """历史存储配置"""
    enabled: bool = True
    storage_type: str = "file"  # file, sqlite
    storage_path: str = "./history"
    index_enabled: bool = True
    index_path: str = "./history/indexes"
    auto_compress: bool = True
    compress_threshold_days: int = 7
    backup_enabled: bool = True
    backup_interval_days: int = 1
    backup_retention_days: int = 30
    max_records_per_session: int = 10000
    retention_days: int = 90
```

### 8.2 配置文件结构
```yaml
# configs/history.yaml
history:
  enabled: true
  storage_type: "file"
  storage_path: "${HISTORY_PATH:./history}"
  index_enabled: true
  index_path: "${HISTORY_PATH:./history}/indexes"
  
  storage:
    file:
      compression: true
      compression_format: "gzip"
      file_rotation: true
      max_file_size_mb: 100
      batch_size: 100
    
    sqlite:
      enable_fts: true
      wal_mode: true
      cache_size_mb: 64
      journal_mode: "WAL"
      synchronous: "NORMAL"
  
  maintenance:
    auto_compress: true
    compress_threshold_days: 7
    backup_enabled: true
    backup_interval_days: 1
    backup_retention_days: 30
    retention_days: 90
```

## 9. 数据迁移策略

### 9.1 迁移工具设计
```python
class DataMigrationTool:
    """数据迁移工具"""
    
    def __init__(self, old_session_store: ISessionStore, new_history_manager: IHistoryManager):
        self.old_store = old_session_store
        self.new_manager = new_history_manager
        self.migration_log: List[Dict[str, Any]] = []
    
    def migrate_all_sessions(self, progress_callback: Optional[Callable[[int, int], None]] = None) -> bool:
        """迁移所有会话"""
        try:
            sessions = self.old_store.list_sessions()
            total = len(sessions)
            
            for i, session_info in enumerate(sessions):
                session_id = session_info["session_id"]
                success = self.migrate_session(session_id)
                
                self.migration_log.append({
                    "session_id": session_id,
                    "success": success,
                    "timestamp": datetime.now().isoformat()
                })
                
                if progress_callback:
                    progress_callback(i + 1, total)
            
            return True
        except Exception as e:
            self.migration_log.append({
                "error": str(e),
                "timestamp": datetime.now().isoformat()
            })
            return False
```

## 10. 实施计划和优先级

### 10.1 第一阶段（核心架构）- 1-2周
**优先级：高**
- [ ] 实现基础数据模型和接口定义
- [ ] 创建HistoryManager核心逻辑
- [ ] 实现文件存储后端
- [ ] 基础配置系统集成
- [ ] 单元测试覆盖

### 10.2 第二阶段（存储和索引）- 2-3周
**优先级：高**
- [ ] SQLite存储后端实现
- [ ] 基础索引系统（Whoosh）
- [ ] 查询处理器实现
- [ ] 性能优化
- [ ] 集成测试

### 10.3 第三阶段（TUI集成）- 2-3周
**优先级：中**
- [ ] TUI适配器实现
- [ ] 渐进式迁移现有代码
- [ ] 兼容性测试
- [ ] UI组件更新

### 10.4 第四阶段（高级功能）- 2-3周
**优先级：中**
- [ ] 数据迁移工具
- [ ] 高级查询功能
- [ ] 分析和统计功能
- [ ] 备份和恢复机制

### 10.5 第五阶段（优化和完善）- 1-2周
**优先级：低**
- [ ] 性能调优
- [ ] 错误处理完善
- [ ] 文档完善
- [ ] 部署和监控

## 11. 关键技术决策

### 11.1 存储技术选择
- **文件存储**: 使用JSONL格式，支持流式读写，易于压缩和备份
- **SQLite存储**: 支持复杂查询和事务，适合大规模数据
- **索引技术**: 使用Whoosh全文索引，支持中文分词和模糊搜索

### 11.2 性能优化策略
- **异步写入**: 使用后台线程处理存储操作
- **批量操作**: 支持批量写入和索引更新
- **缓存机制**: 内存缓存热点数据
- **压缩存储**: 自动压缩历史数据

### 11.3 扩展性设计
- **插件化存储**: 支持多种存储后端
- **事件驱动**: 支持自定义事件处理器
- **配置驱动**: 通过配置文件控制行为
- **API接口**: 为未来Web UI提供支持

## 12. 风险评估和缓解策略

### 12.1 主要风险
1. **数据丢失风险**: 通过备份机制和事务处理缓解
2. **性能影响**: 通过异步处理和缓存缓解
3. **迁移复杂性**: 通过渐进式迁移和回滚机制缓解
4. **存储空间**: 通过压缩和清理策略缓解

### 12.2 缓解措施
- 完善的错误处理和恢复机制
- 全面的测试覆盖
- 详细的迁移文档和工具
- 监控和告警机制

## 13. 总结

本方案设计了一个完全独立于TUI的历史存储系统，具有以下核心优势：

1. **完全解耦**: 历史存储独立于任何UI组件，支持多种访问方式
2. **高性能**: 异步操作、索引机制和缓存策略
3. **高扩展性**: 插件化架构，支持多种存储后端
4. **数据安全**: 备份恢复机制和事务处理
5. **易于维护**: 清晰的分层架构和配置驱动

该方案遵循项目现有的架构模式，与依赖注入系统和配置系统无缝集成，为系统的长期演进奠定了坚实基础。