# 独立历史存储系统快速开始实施指南

## 1. 概述

本指南提供了独立历史存储系统的快速实施路径，帮助开发团队在现有项目基础上快速集成和部署新的历史存储功能。

## 2. 前置条件

### 2.1 环境要求
- Python 3.13+
- 现有的依赖注入系统
- YAML配置系统
- 足够的存储空间（建议至少10GB用于历史数据）

### 2.2 依赖包
```bash
# 核心依赖
uv add whoosh  # 全文搜索
uv add sqlite3  # SQLite存储（Python内置）
uv add pydantic  # 数据验证

# 可选依赖
uv add lz4  # 快速压缩
uv add zstandard  # 高效压缩
uv add psutil  # 系统监控
```

## 3. 第一阶段：核心基础设施（1-2天）

### 3.1 创建基础目录结构
```bash
mkdir -p src/domain/history
mkdir -p src/application/history
mkdir -p src/infrastructure/history
mkdir -p configs/history
```

### 3.2 实现核心接口和模型
```python
# src/domain/history/interfaces.py
from abc import ABC, abstractmethod
from typing import List, Dict, Any, Optional
from datetime import datetime

class IHistoryManager(ABC):
    @abstractmethod
    def record_message(self, record: MessageRecord) -> None: pass
    
    @abstractmethod
    def record_tool_call(self, record: ToolCallRecord) -> None: pass
    
    @abstractmethod
    def query_history(self, query: HistoryQuery) -> HistoryResult: pass

# src/domain/history/models.py
from dataclasses import dataclass, field
from datetime import datetime
from typing import Dict, Any, Optional
from enum import Enum

class MessageType(Enum):
    USER = "user"
    ASSISTANT = "assistant"
    SYSTEM = "system"

@dataclass
class MessageRecord:
    record_id: str
    session_id: str
    timestamp: datetime
    record_type: str = "message"
    message_type: MessageType = MessageType.USER
    content: str = ""
    metadata: Dict[str, Any] = field(default_factory=dict)
```

### 3.3 实现基础文件存储
```python
# src/infrastructure/history/storage/file_storage.py
import json
import threading
from pathlib import Path
from typing import List, Dict, Any, Optional

class FileHistoryStorage:
    def __init__(self, base_path: Path):
        self.base_path = base_path
        self.base_path.mkdir(parents=True, exist_ok=True)
        self._lock = threading.RLock()
    
    def store_record(self, record: MessageRecord) -> bool:
        try:
            with self._lock:
                session_file = self._get_session_file(record.session_id)
                with open(session_file, 'a', encoding='utf-8') as f:
                    json.dump(record.__dict__, f, ensure_ascii=False, default=str)
                    f.write('\n')
            return True
        except Exception:
            return False
    
    def _get_session_file(self, session_id: str) -> Path:
        date_prefix = datetime.now().strftime("%Y%m")
        session_dir = self.base_path / "sessions" / date_prefix
        session_dir.mkdir(exist_ok=True)
        return session_dir / f"{session_id}.jsonl"
```

### 3.4 实现基础历史管理器
```python
# src/application/history/manager.py
from src.domain.history.interfaces import IHistoryManager
from src.domain.history.models import MessageRecord
from src.infrastructure.history.storage.file_storage import FileHistoryStorage

class HistoryManager(IHistoryManager):
    def __init__(self, storage: FileHistoryStorage):
        self.storage = storage
    
    def record_message(self, record: MessageRecord) -> None:
        self.storage.store_record(record)
    
    def record_tool_call(self, record: ToolCallRecord) -> None:
        self.storage.store_record(record)
    
    def query_history(self, query: HistoryQuery) -> HistoryResult:
        # 简单实现，后续优化
        return HistoryResult(records=[])
```

## 4. 第二阶段：TUI集成（2-3天）

### 4.1 创建TUI适配器
```python
# src/application/history/adapters/tui_adapter.py
from src.domain.history.models import MessageRecord, MessageType, ToolCallRecord
from src.presentation.tui.state_manager import StateManager
import uuid
from datetime import datetime

class TUIHistoryAdapter:
    def __init__(self, history_manager: IHistoryManager, state_manager: StateManager):
        self.history_manager = history_manager
        self.state_manager = state_manager
    
    def on_user_message(self, content: str) -> None:
        if not self.state_manager.session_id:
            return
        
        record = MessageRecord(
            record_id=str(uuid.uuid4()),
            session_id=self.state_manager.session_id,
            timestamp=datetime.now(),
            message_type=MessageType.USER,
            content=content
        )
        self.history_manager.record_message(record)
    
    def on_assistant_message(self, content: str) -> None:
        if not self.state_manager.session_id:
            return
        
        record = MessageRecord(
            record_id=str(uuid.uuid4()),
            session_id=self.state_manager.session_id,
            timestamp=datetime.now(),
            message_type=MessageType.ASSISTANT,
            content=content
        )
        self.history_manager.record_message(record)
```

### 4.2 修改TUI状态管理器
```python
# src/presentation/tui/state_manager.py (添加钩子方法)
class StateManager:
    def __init__(self, session_manager: Optional[ISessionManager] = None):
        # ... 现有代码 ...
        self._user_message_hooks = []
        self._assistant_message_hooks = []
        self._tool_call_hooks = []
    
    def add_user_message_hook(self, hook: Callable[[str], None]) -> None:
        self._user_message_hooks.append(hook)
    
    def add_assistant_message_hook(self, hook: Callable[[str], None]) -> None:
        self._assistant_message_hooks.append(hook)
    
    def add_user_message(self, content: str) -> None:
        # ... 现有代码 ...
        
        # 触发钩子
        for hook in self._user_message_hooks:
            try:
                hook(content)
            except Exception:
                pass  # 忽略钩子错误
    
    def add_assistant_message(self, content: str) -> None:
        # ... 现有代码 ...
        
        # 触发钩子
        for hook in self._assistant_message_hooks:
            try:
                hook(content)
            except Exception:
                pass
```

### 4.3 在TUI应用中集成
```python
# src/presentation/tui/app.py (修改初始化部分)
class TUIApp:
    def __init__(self, container: IDependencyContainer):
        # ... 现有代码 ...
        
        # 集成历史存储
        if container.has_service(IHistoryManager):
            history_manager = container.get(IHistoryManager)
            self.history_adapter = TUIHistoryAdapter(
                history_manager=history_manager,
                state_manager=self.state_manager
            )
            
            # 注册钩子
            self.state_manager.add_user_message_hook(
                self.history_adapter.on_user_message
            )
            self.state_manager.add_assistant_message_hook(
                self.history_adapter.on_assistant_message
            )
```

## 5. 第三阶段：配置系统集成（1天）

### 5.1 创建配置文件
```yaml
# configs/history.yaml
history:
  enabled: true
  storage_type: "file"
  storage_path: "${HISTORY_PATH:./history}"
  index_enabled: false  # 第一阶段禁用索引
  auto_compress: false  # 第一阶段禁用压缩
  backup_enabled: false  # 第一阶段禁用备份
```

### 5.2 注册服务到依赖注入容器
```python
# src/infrastructure/history/service_registration.py
from src.infrastructure.container import IDependencyContainer
from src.domain.history.interfaces import IHistoryManager
from src.application.history.manager import HistoryManager
from src.infrastructure.history.storage.file_storage import FileHistoryStorage

def register_history_services(container: IDependencyContainer, config: Dict[str, Any]) -> None:
    history_config = config.get("history", {})
    
    if not history_config.get("enabled", False):
        return
    
    # 注册存储
    storage_path = Path(history_config.get("storage_path", "./history"))
    container.register_instance(
        FileHistoryStorage,
        FileHistoryStorage(storage_path)
    )
    
    # 注册管理器
    container.register(
        IHistoryManager,
        HistoryManager,
        lifetime="singleton"
    )
```

### 5.3 在应用启动时注册服务
```python
# src/main.py (或应用入口文件)
def setup_services(container: IDependencyContainer) -> None:
    # ... 现有服务注册 ...
    
    # 注册历史存储服务
    from src.infrastructure.history.service_registration import register_history_services
    register_history_services(container, config)
```

## 6. 第四阶段：基础测试（1天）

### 6.1 创建单元测试
```python
# tests/unit/application/history/test_manager.py
import pytest
from unittest.mock import Mock

from src.application.history.manager import HistoryManager
from src.domain.history.models import MessageRecord, MessageType

class TestHistoryManager:
    def test_record_message(self):
        mock_storage = Mock()
        manager = HistoryManager(mock_storage)
        
        record = MessageRecord(
            record_id="test-1",
            session_id="session-1",
            timestamp=datetime.now(),
            message_type=MessageType.USER,
            content="测试"
        )
        
        manager.record_message(record)
        mock_storage.store_record.assert_called_once_with(record)
```

### 6.2 创建集成测试
```python
# tests/integration/history/test_tui_integration.py
import pytest
import tempfile
from pathlib import Path

from src.application.history.manager import HistoryManager
from src.infrastructure.history.storage.file_storage import FileHistoryStorage
from src.application.history.adapters.tui_adapter import TUIHistoryAdapter
from src.presentation.tui.state_manager import StateManager

class TestTUIIntegration:
    def test_message_recording(self):
        with tempfile.TemporaryDirectory() as temp_dir:
            # 设置存储
            storage = FileHistoryStorage(Path(temp_dir))
            manager = HistoryManager(storage)
            
            # 设置状态管理器
            state_manager = StateManager()
            state_manager.session_id = "test-session"
            
            # 设置适配器
            adapter = TUIHistoryAdapter(manager, state_manager)
            
            # 模拟用户消息
            adapter.on_user_message("你好")
            
            # 验证记录被保存
            # ... 验证逻辑 ...
```

## 7. 第五阶段：部署和验证（1天）

### 7.1 部署检查清单
- [ ] 配置文件已创建并正确配置
- [ ] 依赖注入服务已注册
- [ ] TUI钩子已正确设置
- [ ] 存储目录权限正确
- [ ] 日志级别适当设置

### 7.2 验证步骤
```bash
# 1. 启动应用
python -m src.presentation.tui.app

# 2. 创建新会话
# 在TUI中创建新会话

# 3. 发送消息
# 发送几条测试消息

# 4. 检查历史文件
ls -la ./history/sessions/
cat ./history/sessions/202410/session-*.jsonl

# 5. 运行测试
pytest tests/unit/application/history/
pytest tests/integration/history/
```

## 8. 常见问题和解决方案

### 8.1 存储权限问题
```bash
# 确保历史目录有写权限
chmod 755 ./history
chmod 644 ./history/sessions/*.jsonl
```

### 8.2 内存使用过高
```python
# 在配置中限制缓存大小
history:
  cache_size_mb: 100
  batch_size: 50
```

### 8.3 性能问题
```python
# 启用异步写入
history:
  async_write: true
  write_interval: 5.0
```

## 9. 下一步计划

### 9.1 短期优化（1-2周）
- [ ] 实现异步写入队列
- [ ] 添加基础索引功能
- [ ] 实现数据压缩
- [ ] 添加查询功能

### 9.2 中期扩展（2-4周）
- [ ] SQLite存储后端
- [ ] 全文搜索功能
- [ ] 数据迁移工具
- [ ] 监控和指标

### 9.3 长期规划（1-2个月）
- [ ] Web API接口
- [ ] 数据分析功能
- [ ] 多租户支持
- [ ] 分布式存储

## 10. 成功指标

### 10.1 功能指标
- [ ] 消息记录成功率 > 99%
- [ ] 查询响应时间 < 100ms
- [ ] 存储空间使用合理

### 10.2 性能指标
- [ ] 不影响TUI响应性能
- [ ] 支持并发写入
- [ ] 内存使用稳定

### 10.3 可靠性指标
- [ ] 数据不丢失
- [ ] 错误恢复机制
- [ ] 完整的测试覆盖

## 11. 团队协作

### 11.1 代码审查要点
- 接口设计是否合理
- 错误处理是否完善
- 测试覆盖是否充分
- 文档是否完整

### 11.2 部署协调
- 配置变更通知
- 数据迁移计划
- 回滚策略
- 监控设置

## 12. 总结

这个快速开始指南提供了独立历史存储系统的分阶段实施路径，从最基础的功能开始，逐步扩展到完整的功能集。通过这种方式，团队可以：

1. **快速验证**：在2-3天内实现基础功能并验证可行性
2. **渐进式集成**：最小化对现有系统的影响
3. **风险控制**：每个阶段都有明确的验证点
4. **团队协作**：清晰的分工和协调机制

遵循这个指南，团队可以在保持系统稳定性的同时，逐步引入强大的历史存储功能，为系统的长期发展奠定坚实基础。