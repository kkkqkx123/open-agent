# 独立历史存储技术实现细节补充

## 1. 依赖注入集成

### 1.1 服务注册配置
```python
# src/infrastructure/history/service_registration.py
from typing import Dict, Any
from src.infrastructure.container import IDependencyContainer, ServiceLifetime
from src.domain.history.interfaces import IHistoryManager, IHistoryStorage, IHistoryIndex
from src.application.history.manager import HistoryManager
from src.infrastructure.history.storage.file_storage import FileHistoryStorage
from src.infrastructure.history.storage.sqlite_storage import SQLiteHistoryStorage
from src.infrastructure.history.index.whoosh_index import WhooshIndexManager
from src.infrastructure.history.config.history_config import HistoryConfig

def register_history_services(container: IDependencyContainer, config: Dict[str, Any]) -> None:
    """注册历史存储相关服务"""
    
    # 注册配置
    history_config = HistoryConfig.from_dict(config.get("history", {}))
    container.register_instance(HistoryConfig, history_config)
    
    # 注册存储后端
    if history_config.storage_type == "file":
        container.register(
            IHistoryStorage,
            FileHistoryStorage,
            lifetime=ServiceLifetime.SINGLETON
        )
    elif history_config.storage_type == "sqlite":
        container.register(
            IHistoryStorage,
            SQLiteHistoryStorage,
            lifetime=ServiceLifetime.SINGLETON
        )
    
    # 注册索引管理器
    if history_config.index_enabled:
        container.register(
            IHistoryIndex,
            WhooshIndexManager,
            lifetime=ServiceLifetime.SINGLETON
        )
    
    # 注册历史管理器
    container.register(
        IHistoryManager,
        HistoryManager,
        lifetime=ServiceLifetime.SINGLETON
    )
```

### 1.2 在TUI应用中的集成
```python
# src/presentation/tui/app.py (修改部分)
from src.application.history.adapters.tui_adapter import TUIHistoryAdapter

class TUIApp:
    def __init__(self, container: IDependencyContainer):
        self.container = container
        self.state_manager = StateManager(
            session_manager=container.get(ISessionManager)
        )
        
        # 集成历史存储
        if container.has_service(IHistoryManager):
            history_manager = container.get(IHistoryManager)
            self.history_adapter = TUIHistoryAdapter(
                history_manager=history_manager,
                state_manager=self.state_manager
            )
            # 替换原有的消息处理逻辑
            self._setup_history_hooks()
    
    def _setup_history_hooks(self):
        """设置历史记录钩子"""
        # 监听用户消息
        self.state_manager.add_user_message_hook(
            self.history_adapter.on_user_message
        )
        
        # 监听助手消息
        self.state_manager.add_assistant_message_hook(
            self.history_adapter.on_assistant_message
        )
        
        # 监听工具调用
        self.state_manager.add_tool_call_hook(
            self.history_adapter.on_tool_call
        )
```

## 2. 异步处理和性能优化

### 2.1 异步写入队列
```python
# src/infrastructure/history/async_writer.py
import asyncio
import threading
from queue import Queue, Empty
from typing import List, Callable, Optional
from concurrent.futures import ThreadPoolExecutor

class AsyncHistoryWriter:
    """异步历史写入器"""
    
    def __init__(
        self,
        storage: IHistoryStorage,
        batch_size: int = 100,
        flush_interval: float = 5.0,
        max_queue_size: int = 1000
    ):
        self.storage = storage
        self.batch_size = batch_size
        self.flush_interval = flush_interval
        self.max_queue_size = max_queue_size
        
        self._queue = Queue(maxsize=max_queue_size)
        self._executor = ThreadPoolExecutor(max_workers=2, thread_name_prefix="history_writer")
        self._stop_event = threading.Event()
        self._writer_thread = None
        self._error_handlers: List[Callable[[Exception], None]] = []
    
    def start(self) -> None:
        """启动异步写入器"""
        if self._writer_thread is None:
            self._stop_event.clear()
            self._writer_thread = threading.Thread(
                target=self._write_loop,
                name="HistoryWriter",
                daemon=True
            )
            self._writer_thread.start()
    
    def stop(self) -> None:
        """停止异步写入器"""
        if self._writer_thread:
            self._stop_event.set()
            self._writer_thread.join(timeout=10.0)
            self._writer_thread = None
        self._executor.shutdown(wait=True)
    
    def write_record(self, record: HistoryRecord) -> bool:
        """写入记录（异步）"""
        try:
            self._queue.put_nowait(record)
            return True
        except Exception:
            # 队列满，记录错误
            return False
    
    def _write_loop(self) -> None:
        """写入循环"""
        batch = []
        last_flush = time.time()
        
        while not self._stop_event.is_set():
            try:
                # 尝试获取记录
                try:
                    record = self._queue.get(timeout=1.0)
                    batch.append(record)
                except Empty:
                    pass
                
                # 检查是否需要刷新
                current_time = time.time()
                should_flush = (
                    len(batch) >= self.batch_size or
                    (batch and current_time - last_flush >= self.flush_interval)
                )
                
                if should_flush and batch:
                    self._flush_batch(batch)
                    batch = []
                    last_flush = current_time
                    
            except Exception as e:
                self._handle_error(e)
```

### 2.2 缓存机制
```python
# src/infrastructure/history/cache/history_cache.py
from typing import Optional, List, Dict, Any
from datetime import datetime, timedelta
import threading
from collections import OrderedDict

class HistoryCache:
    """历史记录缓存"""
    
    def __init__(
        self,
        max_size: int = 1000,
        ttl_seconds: int = 300,  # 5分钟
        cleanup_interval: int = 60  # 1分钟
    ):
        self.max_size = max_size
        self.ttl_seconds = ttl_seconds
        self.cleanup_interval = cleanup_interval
        
        self._cache: OrderedDict[str, CacheEntry] = OrderedDict()
        self._lock = threading.RLock()
        self._last_cleanup = time.time()
    
    def get(self, key: str) -> Optional[Any]:
        """获取缓存项"""
        with self._lock:
            self._maybe_cleanup()
            
            if key not in self._cache:
                return None
            
            entry = self._cache[key]
            if self._is_expired(entry):
                del self._cache[key]
                return None
            
            # 移动到末尾（LRU）
            self._cache.move_to_end(key)
            return entry.value
    
    def put(self, key: str, value: Any) -> None:
        """放入缓存项"""
        with self._lock:
            self._maybe_cleanup()
            
            # 如果已存在，更新
            if key in self._cache:
                self._cache[key] = CacheEntry(value, time.time())
                self._cache.move_to_end(key)
                return
            
            # 检查容量
            while len(self._cache) >= self.max_size:
                self._cache.popitem(last=False)  # 移除最旧的项
            
            # 添加新项
            self._cache[key] = CacheEntry(value, time.time())
```

## 3. 错误处理和恢复机制

### 3.1 错误处理策略
```python
# src/domain/history/exceptions.py
class HistoryError(Exception):
    """历史存储基础异常"""
    pass

class HistoryStorageError(HistoryError):
    """存储错误"""
    pass

class HistoryIndexError(HistoryError):
    """索引错误"""
    pass

class HistoryQueryError(HistoryError):
    """查询错误"""
    pass

class HistoryMigrationError(HistoryError):
    """迁移错误"""
    pass

class HistoryConfigError(HistoryError):
    """配置错误"""
    pass
```

### 3.2 重试机制
```python
# src/infrastructure/history/retry/retry_policy.py
import time
import random
from typing import Callable, Type, Tuple, Optional
from functools import wraps

class RetryPolicy:
    """重试策略"""
    
    def __init__(
        self,
        max_attempts: int = 3,
        base_delay: float = 1.0,
        max_delay: float = 60.0,
        exponential_base: float = 2.0,
        jitter: bool = True
    ):
        self.max_attempts = max_attempts
        self.base_delay = base_delay
        self.max_delay = max_delay
        self.exponential_base = exponential_base
        self.jitter = jitter
    
    def execute(self, func: Callable, *args, **kwargs):
        """执行函数，带重试"""
        last_exception = None
        
        for attempt in range(self.max_attempts):
            try:
                return func(*args, **kwargs)
            except Exception as e:
                last_exception = e
                
                if attempt == self.max_attempts - 1:
                    # 最后一次尝试，直接抛出异常
                    raise e
                
                # 计算延迟时间
                delay = self._calculate_delay(attempt)
                time.sleep(delay)
        
        raise last_exception

def retry_on_exception(
    exceptions: Tuple[Type[Exception], ...] = (Exception,),
    policy: Optional[RetryPolicy] = None
):
    """重试装饰器"""
    if policy is None:
        policy = RetryPolicy()
    
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            return policy.execute(func, *args, **kwargs)
        return wrapper
    return decorator
```

## 4. 监控和指标

### 4.1 性能指标收集
```python
# src/infrastructure/history/metrics/history_metrics.py
import time
from typing import Dict, Any, Optional
from dataclasses import dataclass, field
from threading import Lock

@dataclass
class HistoryMetrics:
    """历史存储指标"""
    
    # 存储指标
    records_stored: int = 0
    store_errors: int = 0
    store_latency_ms: float = 0.0
    store_latency_count: int = 0
    
    # 查询指标
    queries_executed: int = 0
    query_errors: int = 0
    query_latency_ms: float = 0.0
    query_latency_count: int = 0
    
    # 索引指标
    index_updates: int = 0
    index_errors: int = 0
    index_latency_ms: float = 0.0
    index_latency_count: int = 0
    
    # 缓存指标
    cache_hits: int = 0
    cache_misses: int = 0
    
    # 队列指标
    queue_size: int = 0
    queue_full_errors: int = 0
    
    _lock: Lock = field(default_factory=Lock)
    
    def record_store_operation(self, latency_ms: float, success: bool = True) -> None:
        """记录存储操作"""
        with self._lock:
            self.records_stored += 1
            if not success:
                self.store_errors += 1
            
            self.store_latency_ms += latency_ms
            self.store_latency_count += 1
    
    def get_summary(self) -> Dict[str, Any]:
        """获取指标摘要"""
        with self._lock:
            return {
                "storage": {
                    "total_records": self.records_stored,
                    "error_rate": self.store_errors / max(self.records_stored, 1),
                    "avg_latency_ms": self.store_latency_ms / max(self.store_latency_count, 1)
                },
                "query": {
                    "total_queries": self.queries_executed,
                    "error_rate": self.query_errors / max(self.queries_executed, 1),
                    "avg_latency_ms": self.query_latency_ms / max(self.query_latency_count, 1)
                },
                "cache": {
                    "hit_rate": self.cache_hits / max(self.cache_hits + self.cache_misses, 1),
                    "total_hits": self.cache_hits,
                    "total_misses": self.cache_misses
                }
            }
```

## 5. 测试策略

### 5.1 单元测试示例
```python
# tests/unit/application/history/test_manager.py
import pytest
from unittest.mock import Mock, patch
from datetime import datetime

from src.application.history.manager import HistoryManager
from src.domain.history.models import MessageRecord, MessageType
from src.domain.history.exceptions import HistoryStorageError

class TestHistoryManager:
    
    @pytest.fixture
    def mock_storage(self):
        return Mock()
    
    @pytest.fixture
    def mock_index(self):
        return Mock()
    
    @pytest.fixture
    def mock_config(self):
        config = Mock()
        config.enabled = True
        return config
    
    @pytest.fixture
    def history_manager(self, mock_storage, mock_index, mock_config):
        return HistoryManager(
            storage=mock_storage,
            index_manager=mock_index,
            config=mock_config
        )
    
    def test_record_message_success(self, history_manager, mock_storage, mock_index):
        """测试成功记录消息"""
        # 准备测试数据
        record = MessageRecord(
            record_id="test-1",
            session_id="session-1",
            timestamp=datetime.now(),
            record_type="message",
            message_type=MessageType.USER,
            content="测试消息"
        )
        
        # 模拟存储成功
        mock_storage.store_record.return_value = True
        
        # 执行测试
        history_manager.record_message(record)
        
        # 验证调用
        mock_storage.store_record.assert_called_once_with(record)
        mock_index.update_index.assert_called_once_with(record)
```

### 5.2 集成测试示例
```python
# tests/integration/history/test_end_to_end.py
import pytest
import tempfile
import shutil
from pathlib import Path

from src.infrastructure.history.storage.file_storage import FileHistoryStorage
from src.infrastructure.history.index.whoosh_index import WhooshIndexManager
from src.application.history.manager import HistoryManager
from src.infrastructure.history.config.history_config import HistoryConfig, FileStorageConfig
from src.domain.history.models import MessageRecord, MessageType, ToolCallRecord

class TestHistoryEndToEnd:
    
    @pytest.fixture
    def temp_dir(self):
        temp_dir = Path(tempfile.mkdtemp())
        yield temp_dir
        shutil.rmtree(temp_dir)
    
    @pytest.fixture
    def history_config(self, temp_dir):
        return HistoryConfig(
            enabled=True,
            storage_type="file",
            storage_path=str(temp_dir / "history"),
            index_enabled=True,
            index_path=str(temp_dir / "indexes")
        )
    
    def test_full_workflow(self, history_manager):
        """测试完整工作流"""
        session_id = "test-session"
        
        # 记录消息
        user_msg = MessageRecord(
            record_id="msg-1",
            session_id=session_id,
            timestamp=datetime.now(),
            record_type="message",
            message_type=MessageType.USER,
            content="你好"
        )
        history_manager.record_message(user_msg)
        
        # 查询历史
        query = HistoryQuery(session_id=session_id)
        result = history_manager.query_history(query)
        
        # 验证结果
        assert len(result.records) >= 1
        assert any(r.record_id == "msg-1" for r in result.records)
```

## 6. 部署和运维

### 6.1 监控配置
```yaml
# configs/monitoring/history_monitoring.yaml
history_monitoring:
  metrics:
    enabled: true
    interval: 60  # seconds
    endpoint: "/metrics"
  
  alerts:
    storage_error_rate:
      threshold: 0.05  # 5%
      window: 300  # 5 minutes
    
    query_latency:
      threshold: 1000  # ms
      window: 300
    
    queue_size:
      threshold: 800
      window: 60
    
    disk_usage:
      threshold: 0.8  # 80%
      check_interval: 300  # 5 minutes
  
  logging:
    level: "INFO"
    format: "json"
    file: "/app/logs/history.log"
    rotation: "daily"
    retention: 30  # days
```

## 7. 性能基准测试

### 7.1 基准测试脚本
```python
# scripts/benchmark_history.py
import time
import asyncio
import statistics
from typing import List
from concurrent.futures import ThreadPoolExecutor

from src.domain.history.models import MessageRecord, MessageType
from src.application.history.manager import HistoryManager

class HistoryBenchmark:
    
    def __init__(self, history_manager: HistoryManager):
        self.history_manager = history_manager
    
    def benchmark_write_performance(self, num_records: int = 1000) -> Dict[str, float]:
        """基准测试写入性能"""
        latencies = []
        
        for i in range(num_records):
            record = MessageRecord(
                record_id=f"benchmark-{i}",
                session_id="benchmark-session",
                timestamp=datetime.now(),
                record_type="message",
                message_type=MessageType.USER,
                content=f"基准测试消息 {i}"
            )
            
            start_time = time.time()
            self.history_manager.record_message(record)
            latency_ms = (time.time() - start_time) * 1000
            latencies.append(latency_ms)
        
        return {
            "total_records": num_records,
            "avg_latency_ms": statistics.mean(latencies),
            "p95_latency_ms": statistics.quantiles(latencies, n=20)[18],  # 95th percentile
            "p99_latency_ms": statistics.quantiles(latencies, n=100)[98],  # 99th percentile
            "throughput_rps": num_records / (sum(latencies) / 1000)
        }

if __name__ == "__main__":
    # 运行基准测试
    # ... 设置代码 ...
    benchmark = HistoryBenchmark(history_manager)
    
    print("写入性能基准测试:")
    write_results = benchmark.benchmark_write_performance()
    print(f"  平均延迟: {write_results['avg_latency_ms']:.2f}ms")
    print(f"  吞吐量: {write_results['throughput_rps']:.2f} RPS")
```

这个技术实现细节补充文档提供了具体的代码示例和实现指导，涵盖了依赖注入集成、异步处理、错误处理、监控指标、测试策略、部署运维和性能基准测试等关键方面，为独立历史存储系统的实际实施提供了详细的技术参考。