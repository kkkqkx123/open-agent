# 独立历史存储技术实现细节补充

## 1. 依赖注入集成

### 1.1 服务注册配置
```python
# src/infrastructure/history/service_registration.py
from typing import Dict, Any
from src.infrastructure.container import IDependencyContainer, ServiceLifetime
from src.domain.history.interfaces import IHistoryManager, IHistoryStorage, IHistoryIndex
from src.application.history.manager import HistoryManager
from src.infrastructure.history.storage.file_storage import FileHistoryStorage
from src.infrastructure.history.storage.sqlite_storage import SQLiteHistoryStorage
from src.infrastructure.history.index.whoosh_index import WhooshIndexManager
from src.infrastructure.history.config.history_config import HistoryConfig

def register_history_services(container: IDependencyContainer, config: Dict[str, Any]) -> None:
    """注册历史存储相关服务"""
    
    # 注册配置
    history_config = HistoryConfig.from_dict(config.get("history", {}))
    container.register_instance(HistoryConfig, history_config)
    
    # 注册存储后端
    if history_config.storage_type == "file":
        container.register(
            IHistoryStorage,
            FileHistoryStorage,
            lifetime=ServiceLifetime.SINGLETON
        )
    elif history_config.storage_type == "sqlite":
        container.register(
            IHistoryStorage,
            SQLiteHistoryStorage,
            lifetime=ServiceLifetime.SINGLETON
        )
    
    # 注册索引管理器
    if history_config.index_enabled:
        container.register(
            IHistoryIndex,
            WhooshIndexManager,
            lifetime=ServiceLifetime.SINGLETON
        )
    
    # 注册历史管理器
    container.register(
        IHistoryManager,
        HistoryManager,
        lifetime=ServiceLifetime.SINGLETON
    )
```

### 1.2 在TUI应用中的集成
```python
# src/presentation/tui/app.py (修改部分)
from src.application.history.adapters.tui_adapter import TUIHistoryAdapter

class TUIApp:
    def __init__(self, container: IDependencyContainer):
        self.container = container
        self.state_manager = StateManager(
            session_manager=container.get(ISessionManager)
        )
        
        # 集成历史存储
        if container.has_service(IHistoryManager):
            history_manager = container.get(IHistoryManager)
            self.history_adapter = TUIHistoryAdapter(
                history_manager=history_manager,
                state_manager=self.state_manager
            )
            # 替换原有的消息处理逻辑
            self._setup_history_hooks()
    
    def _setup_history_hooks(self):
        """设置历史记录钩子"""
        # 监听用户消息
        self.state_manager.add_user_message_hook(
            self.history_adapter.on_user_message
        )
        
        # 监听助手消息
        self.state_manager.add_assistant_message_hook(
            self.history_adapter.on_assistant_message
        )
        
        # 监听工具调用
        self.state_manager.add_tool_call_hook(
            self.history_adapter.on_tool_call
        )
```

## 2. 异步处理和性能优化

### 2.1 异步写入队列
```python
# src/infrastructure/history/async_writer.py
import asyncio
import threading
from queue import Queue, Empty
from typing import List, Callable, Optional
from concurrent.futures import ThreadPoolExecutor

class AsyncHistoryWriter:
    """异步历史写入器"""
    
    def __init__(
        self,
        storage: IHistoryStorage,
        batch_size: int = 100,
        flush_interval: float = 5.0,
        max_queue_size: int = 1000
    ):
        self.storage = storage
        self.batch_size = batch_size
        self.flush_interval = flush_interval
        self.max_queue_size = max_queue_size
        
        self._queue = Queue(maxsize=max_queue_size)
        self._executor = ThreadPoolExecutor(max_workers=2, thread_name_prefix="history_writer")
        self._stop_event = threading.Event()
        self._writer_thread = None
        self._error_handlers: List[Callable[[Exception], None]] = []
    
    def start(self) -> None:
        """启动异步写入器"""
        if self._writer_thread is None:
            self._stop_event.clear()
            self._writer_thread = threading.Thread(
                target=self._write_loop,
                name="HistoryWriter",
                daemon=True
            )
            self._writer_thread.start()
    
    def stop(self) -> None:
        """停止异步写入器"""
        if self._writer_thread:
            self._stop_event.set()
            self._writer_thread.join(timeout=10.0)
            self._writer_thread = None
        self._executor.shutdown(wait=True)
    
    def write_record(self, record: HistoryRecord) -> bool:
        """写入记录（异步）"""
        try:
            self._queue.put_nowait(record)
            return True
        except Exception:
            # 队列满，记录错误
            return False
    
    def write_records_batch(self, records: List[HistoryRecord]) -> bool:
        """批量写入记录"""
        try:
            for record in records:
                self._queue.put_nowait(record, timeout=1.0)
            return True
        except Exception:
            return False
    
    def _write_loop(self) -> None:
        """写入循环"""
        batch = []
        last_flush = time.time()
        
        while not self._stop_event.is_set():
            try:
                # 尝试获取记录
                try:
                    record = self._queue.get(timeout=1.0)
                    batch.append(record)
                except Empty:
                    pass
                
                # 检查是否需要刷新
                current_time = time.time()
                should_flush = (
                    len(batch) >= self.batch_size or
                    (batch and current_time - last_flush >= self.flush_interval)
                )
                
                if should_flush and batch:
                    self._flush_batch(batch)
                    batch = []
                    last_flush = current_time
                    
            except Exception as e:
                self._handle_error(e)
    
    def _flush_batch(self, batch: List[HistoryRecord]) -> None:
        """刷新批次"""
        try:
            # 在线程池中执行批量写入
            future = self._executor.submit(self._write_batch_to_storage, batch)
            future.result(timeout=30.0)  # 等待写入完成
        except Exception as e:
            self._handle_error(e)
    
    def _write_batch_to_storage(self, batch: List[HistoryRecord]) -> None:
        """写入存储"""
        for record in batch:
            try:
                self.storage.store_record(record)
            except Exception as e:
                # 记录单个记录失败，继续处理其他记录
                self._handle_error(e)
    
    def add_error_handler(self, handler: Callable[[Exception], None]) -> None:
        """添加错误处理器"""
        self._error_handlers.append(handler)
    
    def _handle_error(self, error: Exception) -> None:
        """处理错误"""
        for handler in self._error_handlers:
            try:
                handler(error)
            except Exception:
                # 忽略处理器本身的错误
                pass
```

### 2.2 缓存机制
```python
# src/infrastructure/history/cache/history_cache.py
from typing import Optional, List, Dict, Any
from datetime import datetime, timedelta
import threading
from collections import OrderedDict

class HistoryCache:
    """历史记录缓存"""
    
    def __init__(
        self,
        max_size: int = 1000,
        ttl_seconds: int = 300,  # 5分钟
        cleanup_interval: int = 60  # 1分钟
    ):
        self.max_size = max_size
        self.ttl_seconds = ttl_seconds
        self.cleanup_interval = cleanup_interval
        
        self._cache: OrderedDict[str, CacheEntry] = OrderedDict()
        self._lock = threading.RLock()
        self._last_cleanup = time.time()
    
    def get(self, key: str) -> Optional[Any]:
        """获取缓存项"""
        with self._lock:
            self._maybe_cleanup()
            
            if key not in self._cache:
                return None
            
            entry = self._cache[key]
            if self._is_expired(entry):
                del self._cache[key]
                return None
            
            # 移动到末尾（LRU）
            self._cache.move_to_end(key)
            return entry.value
    
    def put(self, key: str, value: Any) -> None:
        """放入缓存项"""
        with self._lock:
            self._maybe_cleanup()
            
            # 如果已存在，更新
            if key in self._cache:
                self._cache[key] = CacheEntry(value, time.time())
                self._cache.move_to_end(key)
                return
            
            # 检查容量
            while len(self._cache) >= self.max_size:
                self._cache.popitem(last=False)  # 移除最旧的项
            
            # 添加新项
            self._cache[key] = CacheEntry(value, time.time())
    
    def invalidate(self, key: str) -> None:
        """使缓存项失效"""
        with self._lock:
            self._cache.pop(key, None)
    
    def clear(self) -> None:
        """清空缓存"""
        with self._lock:
            self._cache.clear()
    
    def _maybe_cleanup(self) -> None:
        """可能执行清理"""
        current_time = time.time()
        if current_time - self._last_cleanup >= self.cleanup_interval:
            self._cleanup_expired()
            self._last_cleanup = current_time
    
    def _cleanup_expired(self) -> None:
        """清理过期项"""
        expired_keys = []
        for key, entry in self._cache.items():
            if self._is_expired(entry):
                expired_keys.append(key)
        
        for key in expired_keys:
            del self._cache[key]
    
    def _is_expired(self, entry: 'CacheEntry') -> bool:
        """检查是否过期"""
        return time.time() - entry.timestamp > self.ttl_seconds

@dataclass
class CacheEntry:
    """缓存项"""
    value: Any
    timestamp: float
```

## 3. 错误处理和恢复机制

### 3.1 错误处理策略
```python
# src/domain/history/exceptions.py
class HistoryError(Exception):
    """历史存储基础异常"""
    pass

class HistoryStorageError(HistoryError):
    """存储错误"""
    pass

class HistoryIndexError(HistoryError):
    """索引错误"""
    pass

class HistoryQueryError(HistoryError):
    """查询错误"""
    pass

class HistoryMigrationError(HistoryError):
    """迁移错误"""
    pass

class HistoryConfigError(HistoryError):
    """配置错误"""
    pass
```

### 3.2 重试机制
```python
# src/infrastructure/history/retry/retry_policy.py
import time
import random
from typing import Callable, Type, Tuple, Optional
from functools import wraps

class RetryPolicy:
    """重试策略"""
    
    def __init__(
        self,
        max_attempts: int = 3,
        base_delay: float = 1.0,
        max_delay: float = 60.0,
        exponential_base: float = 2.0,
        jitter: bool = True
    ):
        self.max_attempts = max_attempts
        self.base_delay = base_delay
        self.max_delay = max_delay
        self.exponential_base = exponential_base
        self.jitter = jitter
    
    def execute(self, func: Callable, *args, **kwargs):
        """执行函数，带重试"""
        last_exception = None
        
        for attempt in range(self.max_attempts):
            try:
                return func(*args, **kwargs)
            except Exception as e:
                last_exception = e
                
                if attempt == self.max_attempts - 1:
                    # 最后一次尝试，直接抛出异常
                    raise e
                
                # 计算延迟时间
                delay = self._calculate_delay(attempt)
                time.sleep(delay)
        
        raise last_exception
    
    def _calculate_delay(self, attempt: int) -> float:
        """计算延迟时间"""
        delay = self.base_delay * (self.exponential_base ** attempt)
        delay = min(delay, self.max_delay)
        
        if self.jitter:
            # 添加随机抖动
            delay *= (0.5 + random.random() * 0.5)
        
        return delay

def retry_on_exception(
    exceptions: Tuple[Type[Exception], ...] = (Exception,),
    policy: Optional[RetryPolicy] = None
):
    """重试装饰器"""
    if policy is None:
        policy = RetryPolicy()
    
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            return policy.execute(func, *args, **kwargs)
        return wrapper
    return decorator
```

## 4. 监控和指标

### 4.1 性能指标收集
```python
# src/infrastructure/history/metrics/history_metrics.py
import time
from typing import Dict, Any, Optional
from dataclasses import dataclass, field
from threading import Lock

@dataclass
class HistoryMetrics:
    """历史存储指标"""
    
    # 存储指标
    records_stored: int = 0
    store_errors: int = 0
    store_latency_ms: float = 0.0
    store_latency_count: int = 0
    
    # 查询指标
    queries_executed: int = 0
    query_errors: int = 0
    query_latency_ms: float = 0.0
    query_latency_count: int = 0
    
    # 索引指标
    index_updates: int = 0
    index_errors: int = 0
    index_latency_ms: float = 0.0
    index_latency_count: int = 0
    
    # 缓存指标
    cache_hits: int = 0
    cache_misses: int = 0
    
    # 队列指标
    queue_size: int = 0
    queue_full_errors: int = 0
    
    _lock: Lock = field(default_factory=Lock)
    
    def record_store_operation(self, latency_ms: float, success: bool = True) -> None:
        """记录存储操作"""
        with self._lock:
            self.records_stored += 1
            if not success:
                self.store_errors += 1
            
            self.store_latency_ms += latency_ms
            self.store_latency_count += 1
    
    def record_query_operation(self, latency_ms: float, success: bool = True) -> None:
        """记录查询操作"""
        with self._lock:
            self.queries_executed += 1
            if not success:
                self.query_errors += 1
            
            self.query_latency_ms += latency_ms
            self.query_latency_count += 1
    
    def record_index_operation(self, latency_ms: float, success: bool = True) -> None:
        """记录索引操作"""
        with self._lock:
            self.index_updates += 1
            if not success:
                self.index_errors += 1
            
            self.index_latency_ms += latency_ms
            self.index_latency_count += 1
    
    def record_cache_hit(self) -> None:
        """记录缓存命中"""
        with self._lock:
            self.cache_hits += 1
    
    def record_cache_miss(self) -> None:
        """记录缓存未命中"""
        with self._lock:
            self.cache_misses += 1
    
    def update_queue_size(self, size: int) -> None:
        """更新队列大小"""
        with self._lock:
            self.queue_size = size
    
    def record_queue_full_error(self) -> None:
        """记录队列满错误"""
        with self._lock:
            self.queue_full_errors += 1
    
    def get_summary(self) -> Dict[str, Any]:
        """获取指标摘要"""
        with self._lock:
            return {
                "storage": {
                    "total_records": self.records_stored,
                    "error_rate": self.store_errors / max(self.records_stored, 1),
                    "avg_latency_ms": self.store_latency_ms / max(self.store_latency_count, 1)
                },
                "query": {
                    "total_queries": self.queries_executed,
                    "error_rate": self.query_errors / max(self.queries_executed, 1),
                    "avg_latency_ms": self.query_latency_ms / max(self.query_latency_count, 1)
                },
                "index": {
                    "total_updates": self.index_updates,
                    "error_rate": self.index_errors / max(self.index_updates, 1),
                    "avg_latency_ms": self.index_latency_ms / max(self.index_latency_count, 1)
                },
                "cache": {
                    "hit_rate": self.cache_hits / max(self.cache_hits + self.cache_misses, 1),
                    "total_hits": self.cache_hits,
                    "total_misses": self.cache_misses
                },
                "queue": {
                    "current_size": self.queue_size,
                    "full_errors": self.queue_full_errors
                }
            }

class HistoryMetricsCollector:
    """历史指标收集器"""
    
    def __init__(self):
        self.metrics = HistoryMetrics()
        self._start_time = time.time()
    
    def time_store_operation(self):
        """存储操作计时上下文管理器"""
        return OperationTimer(self.metrics.record_store_operation)
    
    def time_query_operation(self):
        """查询操作计时上下文管理器"""
        return OperationTimer(self.metrics.record_query_operation)
    
    def time_index_operation(self):
        """索引操作计时上下文管理器"""
        return OperationTimer(self.metrics.record_index_operation)

@dataclass
class OperationTimer:
    """操作计时器"""
    record_func: Callable[[float, bool], None]
    start_time: float = field(default_factory=time.time)
    success: bool = True
    
    def __enter__(self):
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        latency_ms = (time.time() - self.start_time) * 1000
        success = exc_type is None
        self.record_func(latency_ms, success)
```

## 5. 测试策略

### 5.1 单元测试示例
```python
# tests/unit/application/history/test_manager.py
import pytest
from unittest.mock import Mock, patch
from datetime import datetime

from src.application.history.manager import HistoryManager
from src.domain.history.models import MessageRecord, MessageType
from src.domain.history.exceptions import HistoryStorageError

class TestHistoryManager:
    
    @pytest.fixture
    def mock_storage(self):
        return Mock()
    
    @pytest.fixture
    def mock_index(self):
        return Mock()
    
    @pytest.fixture
    def mock_config(self):
        config = Mock()
        config.enabled = True
        return config
    
    @pytest.fixture
    def history_manager(self, mock_storage, mock_index, mock_config):
        return HistoryManager(
            storage=mock_storage,
            index_manager=mock_index,
            config=mock_config
        )
    
    def test_record_message_success(self, history_manager, mock_storage, mock_index):
        """测试成功记录消息"""
        # 准备测试数据
        record = MessageRecord(
            record_id="test-1",
            session_id="session-1",
            timestamp=datetime.now(),
            record_type="message",
            message_type=MessageType.USER,
            content="测试消息"
        )
        
        # 模拟存储成功
        mock_storage.store_record.return_value = True
        
        # 执行测试
        history_manager.record_message(record)
        
        # 验证调用
        mock_storage.store_record.assert_called_once_with(record)
        mock_index.update_index.assert_called_once_with(record)
    
    def test_record_message_storage_error(self, history_manager, mock_storage, mock_index):
        """测试存储错误处理"""
        # 准备测试数据
        record = MessageRecord(
            record_id="test-1",
            session_id="session-1",
            timestamp=datetime.now(),
            record_type="message",
            message_type=MessageType.USER,
            content="测试消息"
        )
        
        # 模拟存储失败
        mock_storage.store_record.side_effect = HistoryStorageError("存储失败")
        
        # 执行测试并验证异常
        with pytest.raises(HistoryStorageError):
            history_manager.record_message(record)
        
        # 验证索引没有被更新
        mock_index.update_index.assert_not_called()
    
    def test_query_history(self, history_manager, mock_storage):
        """测试查询历史"""
        # 准备测试数据
        query = HistoryQuery(session_id="session-1", limit=10)
        expected_records = [
            MessageRecord(
                record_id="test-1",
                session_id="session-1",
                timestamp=datetime.now(),
                record_type="message",
                message_type=MessageType.USER,
                content="消息1"
            )
        ]
        
        # 模拟存储返回
        mock_storage.get_records.return_value = expected_records
        
        # 执行测试
        result = history_manager.query_history(query)
        
        # 验证结果
        assert result.records == expected_records
        mock_storage.get_records.assert_called_once_with(query)
```

### 5.2 集成测试示例
```python
# tests/integration/history/test_end_to_end.py
import pytest
import tempfile
import shutil
from pathlib import Path

from src.infrastructure.history.storage.file_storage import FileHistoryStorage
from src.infrastructure.history.index.whoosh_index import WhooshIndexManager
from src.application.history.manager import HistoryManager
from src.infrastructure.history.config.history_config import HistoryConfig, FileStorageConfig
from src.domain.history.models import MessageRecord, MessageType, ToolCallRecord
from src.domain.history.query import HistoryQuery, SearchQuery

class TestHistoryEndToEnd:
    
    @pytest.fixture
    def temp_dir(self):
        temp_dir = Path(tempfile.mkdtemp())
        yield temp_dir
        shutil.rmtree(temp_dir)
    
    @pytest.fixture
    def history_config(self, temp_dir):
        return HistoryConfig(
            enabled=True,
            storage_type="file",
            storage_path=str(temp_dir / "history"),
            index_enabled=True,
            index_path=str(temp_dir / "indexes")
        )
    
    @pytest.fixture
    def history_manager(self, history_config, temp_dir):
        # 创建存储
        storage = FileHistoryStorage(
            base_path=temp_dir / "history",
            config=FileStorageConfig()
        )
        
        # 创建索引
        index_manager = WhooshIndexManager(
            index_path=temp_dir / "indexes",
            config=IndexConfig()
        )
        
        # 创建管理器
        return HistoryManager(
            storage=storage,
            index_manager=index_manager,
            config=history_config
        )
    
    def test_full_workflow(self, history_manager):
        """测试完整工作流"""
        session_id = "test-session"
        
        # 记录消息
        user_msg = MessageRecord(
            record_id="msg-1",
            session_id=session_id,
            timestamp=datetime.now(),
            record_type="message",
            message_type=MessageType.USER,
            content="你好"
        )
        history_manager.record_message(user_msg)
        
        assistant_msg = MessageRecord(
            record_id="msg-2",
            session_id=session_id,
            timestamp=datetime.now(),
            record_type="message",
            message_type=MessageType.ASSISTANT,
            content="你好！有什么可以帮助你的吗？"
        )
        history_manager.record_message(assistant_msg)
        
        # 记录工具调用
        tool_call = ToolCallRecord(
            record_id="tool-1",
            session_id=session_id,
            timestamp=datetime.now(),
            record_type="tool_call",
            tool_name="calculator",
            tool_type="native",
            parameters={"expression": "2+2"},
            result=4,
            success=True
        )
        history_manager.record_tool_call(tool_call)
        
        # 查询历史
        query = HistoryQuery(session_id=session_id)
        result = history_manager.query_history(query)
        
        # 验证结果
        assert len(result.records) == 3
        assert any(r.record_id == "msg-1" for r in result.records)
        assert any(r.record_id == "msg-2" for r in result.records)
        assert any(r.record_id == "tool-1" for r in result.records)
        
        # 搜索测试
        search_query = SearchQuery(query="你好", session_id=session_id)
        search_result = history_manager.search_history(search_query)
        
        # 验证搜索结果
        assert len(search_result) > 0
        assert any("你好" in r.content for r in search_result if isinstance(r, MessageRecord))
```

## 6. 部署和运维

### 6.1 Docker配置
```dockerfile
# Dockerfile.history
FROM python:3.13-slim

# 安装系统依赖
RUN apt-get update && apt-get install -y \
    gcc \
    g++ \
    && rm -rf /var/lib/apt/lists/*

# 安装Python依赖
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# 创建应用目录
WORKDIR /app

# 复制应用代码
COPY src/ ./src/
COPY configs/ ./configs/

# 创建历史数据目录
RUN mkdir -p /app/history /app/logs

# 设置环境变量
ENV PYTHONPATH=/app
ENV HISTORY_PATH=/app/history

# 暴露端口（如果需要）
EXPOSE 8080

# 启动命令
CMD ["python", "-m", "src.presentation.cli.main"]
```

### 6.2 监控配置
```yaml
# configs/monitoring/history_monitoring.yaml
history_monitoring:
  metrics:
    enabled: true
    interval: 60  # seconds
    endpoint: "/metrics"
  
  alerts:
    storage_error_rate:
      threshold: 0.05  # 5%
      window: 300  # 5 minutes
    
    query_latency:
      threshold: 1000  # ms
      window: 300
    
    queue_size:
      threshold: 800
      window: 60
    
    disk_usage:
      threshold: 0.8  # 80%
      check_interval: 300  # 5 minutes
  
  logging:
    level: "INFO"
    format: "json"
    file: "/app/logs/history.log"
    rotation: "daily"
    retention: 30  # days
```

## 7. 性能基准测试

### 7.1 基准测试脚本
```python
# scripts/benchmark_history.py
import time
import asyncio
import statistics
from typing import List
from concurrent.futures import ThreadPoolExecutor

from src.domain.history.models import MessageRecord, MessageType
from src.application.history.manager import HistoryManager

class HistoryBenchmark:
    
    def __init__(self, history_manager: HistoryManager):
        self.history_manager = history_manager
    
    def benchmark_write_performance(self, num_records: int = 1000) -> Dict[str, float]:
        """基准测试写入性能"""
        latencies = []
        
        for i in range(num_records):
            record = MessageRecord(
                record_id=f"benchmark-{i}",
                session_id="benchmark-session",
                timestamp=datetime.now(),
                record_type="message",
                message_type=MessageType.USER,
                content=f"基准测试消息 {i}"
            )
            
            start_time = time.time()
            self.history_manager.record_message(record)
            latency_ms = (time.time() - start_time) * 1000
            latencies.append(latency_ms)
        
        return {
            "total_records": num_records,
            "avg_latency_ms": statistics.mean(latencies),
            "p95_latency_ms": statistics.quantiles(latencies, n=20)[18],  # 95th percentile
            "p99_latency_ms": statistics.quantiles(latencies, n=100)[98],  # 99th percentile
            "throughput_rps": num_records / (sum(latencies) / 1000)
        }
    
    def benchmark_query_performance(self, session_id: str, num_queries: int = 100) -> Dict[str, float]:
        """基准测试查询性能"""
        latencies = []
        
        for i in range(num_queries):
            query = HistoryQuery(session_id=session_id, limit=50)
            
            start_time = time.time()
            result = self.history_manager.query_history(query)
            latency_ms = (time.time() - start_time) * 1000
            latencies.append(latency_ms)
        
        return {
            "total_queries": num_queries,
            "avg_latency_ms": statistics.mean(latencies),
            "p95_latency_ms": statistics.quantiles(latencies, n=20)[18],
            "p99_latency_ms": statistics.quantiles(latencies, n=100)[98],
            "avg_result_count": sum(len(r.records) for r in results) / num_queries
        }
    
    def benchmark_concurrent_writes(self, num_threads: int = 10, records_per_thread: int = 100) -> Dict[str, float]:
        """基准测试并发写入性能"""
        def write_records(thread_id: int):
            latencies = []
            for i in range(records_per_thread):
                record = MessageRecord(
                    record_id=f"concurrent-{thread_id}-{i}",
                    session_id=f"concurrent-session-{thread_id}",
                    timestamp=datetime.now(),
                    record_type="message",
                    message_type=MessageType.USER,
                    content=f"并发测试消息 {thread_id}-{i}"
                )
                
                start_time = time.time()
                self.history_manager.record_message(record)
                latency_ms = (time.time() - start_time) * 1000
                latencies.append(latency_ms)
            
            return latencies
        
        with ThreadPoolExecutor(max_workers=num_threads) as executor:
            futures = [executor.submit(write_records, i) for i in range(num_threads)]
            all_latencies = []
            
            for future in futures:
                all_latencies.extend(future.result())
        
        total_records = num_threads * records_per_thread
        
        return {
            "total_records": total_records,
            "num_threads": num_threads,
            "avg_latency_ms": statistics.mean(all_latencies),
            "p95_latency_ms": statistics.quantiles(all_latencies, n=20)[18],
            "throughput_rps": total_records / (sum(all_latencies) / 1000)
        }

if __name__ == "__main__":
    # 运行基准测试
    # ... 设置代码 ...
    benchmark = HistoryBenchmark(history_manager)
    
    print("写入性能基准测试:")
    write_results = benchmark.benchmark_write_performance()
    print(f"  平均延迟: {write_results['avg_latency_ms']:.2f}ms")
    print(f"  吞吐量: {write_results['throughput_rps']:.2f} RPS")
    
    print("\n查询性能基准测试:")
    query_results = benchmark.benchmark_query_performance("benchmark-session")
    print(f"  平均延迟: {query_results['avg_latency_ms']:.2f}ms")
    print(f"  平均结果数: {query_results['avg_result_count']:.1f}")
    
    print("\n并发写入性能基准测试:")
    concurrent_results = benchmark.benchmark_concurrent_writes()
    print(f"  平均延迟: {concurrent_results['avg_latency_ms']:.2f}ms")
    print(f"  吞吐量: {concurrent_results['throughput_rps']:.2f} RPS")
```

这个技术实现细节补充文档提供了具体的代码示例和实现指导，涵盖了依赖注入集成、异步处理、错误处理、监控指标、测试策略、部署运维和性能基准测试等关键方面，为独立历史存储系统的实际实施提供了详细的技术参考。