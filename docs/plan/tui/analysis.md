# 主要问题

## 1. 中断点布局导致输入区域缺失与 info 区域未注册
**位置：** `src/presentation/tui/layout.py:225-238`  
- **问题描述：**  
  在中等断点（medium breakpoint）布局中，直接将 `INPUT` 区域替换为 `bottom` 容器，导致 `LayoutRegion.INPUT` 整段丢失。用户在终端尺寸接近 `100×30` 时无法输入。
- **附加问题：**  
  新增的 `info` 区域既未在 `LayoutRegion` 枚举中注册，也缺少内容更新逻辑，始终显示为空。

---

## 2. 布局重计算触发条件过于宽松
**位置：** `src/presentation/tui/layout.py:455-472`  
- **问题描述：**  
  `resize_layout` 方法仅在宽度差 > 10 或高度差 > 5 时才触发重新计算布局断点。
- **后果：**  
  类似从宽度 `95 → 103` 的调整虽跨越了断点阈值（如 100），但由于变化量 ≤ 8，不会触发重建，界面长期停留在错误布局状态。

---

## 3. 大屏布局中 langgraph 区域被忽略但资源仍分配
**位置：** `src/presentation/tui/layout.py:193-210` 与 `:599-606`  
- **问题描述：**  
  在大屏布局中，`langgraph` 区域被彻底移除，未创建对应 UI 组件，尽管其配置和逻辑依然存在。
- **矛盾点：**  
  `_calculate_optimal_sizes` 仍在为其分配宽度资源，造成逻辑与渲染割裂，浪费空间且难以维护。

---

## 4. 尺寸计算逻辑混淆横纵方向
**位置：** `src/presentation/tui/layout.py:557-633`  
- **问题描述：**  
  尺寸计算与查询严重混淆了“横向”与“纵向”概念：
  - 在行布局中使用 `available_height` 设置宽度；
  - `get_region_size` 判断方向时误用 `self.layout.split == "column"`（实际该字段是方法对象而非字符串）；
- **后果：**  
  返回尺寸与真实渲染严重偏离，自适应策略无法有效校验与调试。

---

## 5. 侧边栏尺寸依赖高度导致异常宽度过大
**位置：** `src/presentation/tui/layout.py:569-592`  
- **问题描述：**  
  中断点下侧边栏宽度由 `available_height // 3` 决定，即基于可用高度计算宽度。
- **问题场景：**  
  当窗口宽度不足但高度充裕时，侧边栏获得过宽尺寸，严重压缩主区域。
- **缺失机制：**  
  缺乏最小/最大宽度约束，且未根据语义合理绑定尺寸维度。

---

# 修改建议

### ✅ 恢复中断点下的输入区域
- 在 `medium` 断点布局中，采用如下结构：
  ```
  header → main → input → status
  ```
- 若需弹出侧边栏，可在 `main` 内部或额外容器中实现；
- 若必须使用底部容器，至少保留一个 `input` 子布局以确保可输入。

---

### ✅ 调整 `resize_layout` 触发机制
- **方案一：降低阈值**  
  改为宽度差 > 5、高度差 > 3 即触发。
- **方案二：断点感知强制重建**  
  记录上一次生效的断点名称，在每次尺寸变化时立即比较当前应属断点，若不同则强制重建布局。
- 推荐结合两者，兼顾性能与响应性。

---

### ✅ 显式处理大屏下的 `langgraph` 区域
- 在大屏布局中显式创建 `langgraph` 区域，例如：
  - 使用三列布局（左：sidebar，中：main，右：langgraph）；
  - 或作为可选右侧面板，按配置 `visible` 动态挂载。
- **一致性要求：**  
  若决定隐藏，则应在布局定义和组件初始化中同步移除，避免残留逻辑或空间分配。

---

### ✅ 重构尺寸计算与查询逻辑
- **核心原则：** 根据父节点布局方向分别处理宽高。
- **实现建议：**
  - 创建布局时记录每个区域所处的父级方向（horizontal / vertical）；
  - 在 `_calculate_optimal_sizes` 和 `get_region_size` 中依据方向正确应用 `width` / `height`；
  - 修复对 `split` 属性的错误判断方式（应检查 `.is_column()` 或类似接口）；
- 最终目标：返回可信、可预测的尺寸值，支持后续自适应策略验证。

---

### ✅ 添加区域尺寸约束机制
- 为关键区域（如侧边栏、主区）设置合理的最小/最大限制：
  - 侧边栏宽度建议基于终端总宽度百分比（如 20%-30%），而非高度；
  - 引入 `min_width`, `max_width`, `min_height` 等参数；
- **配置化支持：**  
  可通过 `RegionConfig` 或全局配置文件暴露调节接口，提升灵活性。

---

### ✅ 补充尺寸相关的测试覆盖
- 建议增加单元测试或集成测试，模拟多种终端尺寸（如 80×25, 100×30, 120×40 等）；
- 测试断言应包括：
  - 关键区域（如 INPUT、LANGGRAPH）是否存在；
  - 各区域尺寸是否落在预期范围内；
  - 布局切换是否正确触发；
- 目标：防止未来修改引发回归问题。

---

> **建议优先级排序参考：**
> 1. 修复输入栏缺失（用户体验阻塞性问题）  
> 2. 修正 resize 触发逻辑（影响所有断点切换）  
> 3. 重构尺寸计算方向错误（基础逻辑缺陷）  
> 4. 补全 langgraph 显示逻辑（功能完整性）  
> 5. 增加尺寸约束与测试（长期可维护性）
