# TUI界面虚拟滚动和统一输出方案

## 问题分析

### 当前问题
1. **界面分散**：工具调用列表、流式输出、历史消息在不同的UI容器中显示
2. **空间利用率低**：多个面板占用空间，无法充分利用主界面
3. **执行顺序不清晰**：用户难以理解事件的时间顺序和依赖关系
4. **刷新频繁**：流式输出频繁触发界面刷新，影响性能

### 用户需求
- 统一在主UI容器输出，方便查看执行顺序
- 简化UI设计，提高空间利用率
- 节点切换、触发器触发、工作流触发等信息一起输出
- 流式输出改为分段输出，避免频繁刷新

## 技术方案

### 1. 统一时间线输出系统

#### 核心组件设计
```python
class UnifiedTimelineComponent:
    """统一时间线输出组件"""
    
    def __init__(self, max_events: int = 1000):
        self.max_events = max_events
        self.events: List[TimelineEvent] = []
        self.virtual_scroll_offset = 0
        self.visible_range = (0, 50)  # 虚拟滚动可见范围
        
    def add_event(self, event: TimelineEvent) -> None:
        """添加事件到时间线"""
        self.events.append(event)
        # 限制事件数量，支持虚拟滚动
        if len(self.events) > self.max_events:
            self.events = self.events[-self.max_events:]
```

#### 事件类型定义
```python
@dataclass
class TimelineEvent:
    """时间线事件基类"""
    timestamp: datetime
    event_type: str
    content: str
    metadata: Dict[str, Any] = field(default_factory=dict)
    level: str = "info"  # info, warning, error, success

class UserMessageEvent(TimelineEvent):
    """用户消息事件"""
    event_type = "user_message"

class AssistantMessageEvent(TimelineEvent):
    """助手消息事件"""
    event_type = "assistant_message"

class ToolCallStartEvent(TimelineEvent):
    """工具调用开始事件"""
    event_type = "tool_call_start"

class ToolCallEndEvent(TimelineEvent):
    """工具调用结束事件"""
    event_type = "tool_call_end"

class NodeSwitchEvent(TimelineEvent):
    """节点切换事件"""
    event_type = "node_switch"

class TriggerEvent(TimelineEvent):
    """触发器触发事件"""
    event_type = "trigger"

class WorkflowEvent(TimelineEvent):
    """工作流事件"""
    event_type = "workflow"

class StreamSegmentEvent(TimelineEvent):
    """流式输出分段事件"""
    event_type = "stream_segment"
```

### 2. 虚拟滚动实现

#### 虚拟滚动算法
```python
class VirtualScrollManager:
    """虚拟滚动管理器"""
    
    def __init__(self, total_items: int, visible_height: int, item_height: int = 1):
        self.total_items = total_items
        self.visible_height = visible_height
        self.item_height = item_height
        self.scroll_offset = 0
        self.visible_start = 0
        self.visible_end = 0
        
    def update_visible_range(self) -> Tuple[int, int]:
        """更新可见范围"""
        max_visible_items = self.visible_height // self.item_height
        self.visible_start = self.scroll_offset
        self.visible_end = min(self.visible_start + max_visible_items, self.total_items)
        return self.visible_start, self.visible_end
        
    def scroll_to(self, position: int) -> None:
        """滚动到指定位置"""
        self.scroll_offset = max(0, min(position, self.total_items - 1))
        
    def scroll_by(self, delta: int) -> None:
        """相对滚动"""
        self.scroll_to(self.scroll_offset + delta)
```

#### Rich库虚拟滚动集成
```python
class VirtualScrollRenderable:
    """虚拟滚动可渲染对象"""
    
    def __init__(self, timeline_component: UnifiedTimelineComponent):
        self.timeline = timeline_component
        self.scroll_manager = VirtualScrollManager(
            total_items=len(timeline_component.events),
            visible_height=30  # 假设终端高度
        )
        
    def __rich_console__(self, console: Console, options: ConsoleOptions) -> RenderResult:
        """Rich渲染接口"""
        # 更新可见范围
        start, end = self.scroll_manager.update_visible_range()
        
        # 只渲染可见项
        visible_events = self.timeline.events[start:end]
        
        for event in visible_events:
            yield self._render_event(event)
            
    def _render_event(self, event: TimelineEvent) -> Union[Text, Panel]:
        """渲染单个事件"""
        # 根据事件类型使用不同的样式
        event_styles = {
            "user_message": ("👤", "blue"),
            "assistant_message": ("🤖", "green"), 
            "tool_call_start": ("🔧", "magenta"),
            "tool_call_end": ("✅", "green"),
            "node_switch": ("🔄", "cyan"),
            "trigger": ("⚡", "yellow"),
            "workflow": ("📋", "white"),
            "stream_segment": ("📝", "dim")
        }
        
        icon, style = event_styles.get(event.event_type, ("❓", "white"))
        time_str = event.timestamp.strftime("%H:%M:%S")
        
        content = Text()
        content.append(f"{time_str} {icon} ", style=style)
        content.append(event.content)
        
        return content
```

### 3. 分段流式输出

#### 分段输出管理器
```python
class SegmentedStreamOutput:
    """分段流式输出管理器"""
    
    def __init__(self, segment_size: int = 200):
        self.segment_size = segment_size
        self.current_segment = ""
        self.segments: List[str] = []
        self.is_streaming = False
        
    def add_content(self, content: str) -> None:
        """添加流式内容，按段分割"""
        self.current_segment += content
        
        # 当达到分段大小时，创建新事件
        if len(self.current_segment) >= self.segment_size:
            self._flush_segment()
            
    def _flush_segment(self) -> None:
        """刷新当前分段"""
        if self.current_segment:
            # 创建流式分段事件
            event = StreamSegmentEvent(
                timestamp=datetime.now(),
                content=self.current_segment,
                metadata={"segment_index": len(self.segments)}
            )
            
            # 添加到时间线
            timeline_component.add_event(event)
            self.segments.append(self.current_segment)
            self.current_segment = ""
            
    def end_stream(self) -> None:
        """结束流式输出，刷新剩余内容"""
        if self.current_segment:
            self._flush_segment()
        self.is_streaming = False
```

### 4. 集成架构设计

#### 新的主内容区组件
```python
class UnifiedMainContentComponent:
    """统一主内容区组件"""
    
    def __init__(self):
        self.timeline = UnifiedTimelineComponent()
        self.stream_manager = SegmentedStreamOutput()
        self.virtual_renderable = VirtualScrollRenderable(self.timeline)
        
    def add_user_message(self, content: str) -> None:
        """添加用户消息"""
        event = UserMessageEvent(
            timestamp=datetime.now(),
            content=content
        )
        self.timeline.add_event(event)
        
    def add_assistant_message(self, content: str) -> None:
        """添加助手消息"""
        event = AssistantMessageEvent(
            timestamp=datetime.now(),
            content=content
        )
        self.timeline.add_event(event)
        
    def add_tool_call(self, tool_name: str, success: bool, result: Any = None) -> None:
        """添加工具调用"""
        # 开始事件
        start_event = ToolCallStartEvent(
            timestamp=datetime.now(),
            content=f"调用工具: {tool_name}"
        )
        self.timeline.add_event(start_event)
        
        # 结束事件
        status = "成功" if success else "失败"
        end_event = ToolCallEndEvent(
            timestamp=datetime.now(),
            content=f"工具调用{status}: {tool_name}",
            level="success" if success else "error"
        )
        self.timeline.add_event(end_event)
        
    def add_node_switch(self, from_node: str, to_node: str) -> None:
        """添加节点切换事件"""
        event = NodeSwitchEvent(
            timestamp=datetime.now(),
            content=f"节点切换: {from_node} → {to_node}"
        )
        self.timeline.add_event(event)
        
    def add_stream_content(self, content: str) -> None:
        """添加流式内容"""
        self.stream_manager.add_content(content)
        
    def render(self) -> Panel:
        """渲染统一时间线"""
        return Panel(
            self.virtual_renderable,
            title="📋 执行时间线",
            border_style="white"
        )
```

## 界面布局优化

### 新的布局结构
```
+-------------------------------------------------+
|               状态栏 (Status Bar)                |
+-------------------------------------------------+
|                                                 |
|             统一时间线输出区域                   |
|              (支持虚拟滚动)                     |
|                                                 |
|                                                 |
+-------------------------------------------------+
|             输入区域 (Input Area)                |
+-------------------------------------------------+
|             快捷键提示 (Shortcuts)               |
+-------------------------------------------------+
```

### 空间利用率对比
- **当前设计**：三个面板水平分割，每个面板宽度有限
- **新设计**：单一时间线容器，充分利用整个宽度
- **空间提升**：主内容区宽度从33%提升到100%

## 性能优化策略

### 1. 虚拟滚动优化
- 只渲染可见区域的事件
- 使用事件缓存避免重复计算
- 增量更新机制

### 2. 分段输出优化
- 流式输出按200字符分段
- 减少界面刷新频率
- 批量更新机制

### 3. 内存管理
- 事件数量限制（默认1000条）
- 自动清理旧事件
- 压缩存储机制

## 实施计划

### 第一阶段：核心组件开发 (2天)
1. 实现`UnifiedTimelineComponent`和事件类型
2. 实现`VirtualScrollManager`虚拟滚动
3. 实现`SegmentedStreamOutput`分段输出

### 第二阶段：集成测试 (1天)
1. 替换现有主内容区组件
2. 测试虚拟滚动性能
3. 验证分段输出效果

### 第三阶段：界面优化 (1天)
1. 更新布局管理器
2. 添加快捷键支持
3. 性能调优和测试

## 预期效果

### 用户体验提升
1. **执行顺序清晰**：所有事件按时间顺序显示
2. **空间利用率高**：单一容器充分利用界面宽度
3. **性能优化**：虚拟滚动支持大量历史记录
4. **交互流畅**：分段输出减少界面闪烁

### 技术优势
1. **模块化设计**：易于扩展新事件类型
2. **性能优化**：虚拟滚动支持无限扩展
3. **可维护性**：统一的事件处理机制
4. **兼容性**：保持现有API接口不变

## 风险评估

### 技术风险
- **虚拟滚动复杂性**：需要精确计算可见区域
- **性能瓶颈**：大量事件时的渲染性能
- **兼容性问题**：现有功能集成

### 缓解措施
- 分阶段实施，充分测试
- 性能监控和优化
- 保持向后兼容性

这个方案将显著提升TUI界面的用户体验和性能，同时保持代码的可维护性和扩展性。