# 模块配置加载修改方案

## 概述

本文档分析各模块现有的独立配置加载实现，并提供修改方案以复用统一的配置系统。

## 现有模块配置加载分析

### 1. LLM模块 (`src/core/llm/config_manager.py`)

**现有实现特点**:
- 独立的 `LLMConfigManager` 类
- 自定义配置验证规则 (`ConfigValidator`)
- 基于 watchdog 的热重载机制
- 客户端配置缓存 (`_client_configs`)
- 模块配置缓存 (`_module_config`)

**需要保留的功能**:
- LLM特定的验证规则
- 客户端配置管理
- 热重载功能

**修改方案**:
```python
class LLMConfigManagerDecorator:
    """LLM配置管理器装饰器"""
    
    def __init__(self, base_manager: ConfigManager):
        self.base_manager = base_manager
        self.client_configs: Dict[str, LLMClientConfig] = {}
        self.module_config: Optional[LLMModuleConfig] = None
        self.validator = LLMConfigValidator()  # 保留特定验证器
    
    def load_config(self, config_path: str, module_type: Optional[str] = None) -> Dict[str, Any]:
        # 委托给基础管理器，但添加LLM特定处理
        config = self.base_manager.load_config(config_path, "llm")
        
        # LLM特定的配置处理
        if config_path.endswith("_group.yaml"):
            self.module_config = LLMModuleConfig.from_dict(config)
        else:
            client_config = LLMClientConfig.from_dict(config)
            model_key = f"{client_config.model_type}:{client_config.model_name}"
            self.client_configs[model_key] = client_config
        
        return config
```

### 2. 工作流模块

#### 2.1 节点函数加载器 (`src/core/workflow/graph/node_functions/loader.py`)

**现有实现特点**:
- 直接使用 `yaml.safe_load()` 加载配置
- 绕过了统一配置系统
- 缺少缓存和验证功能

**修改方案**:
```python
class NodeFunctionLoader:
    def __init__(self, config_manager: Optional[ConfigManager] = None):
        self.config_manager = config_manager or get_default_manager()
    
    def _load_node_functions_from_directory(self, dir_path: Path) -> None:
        for config_file in dir_path.glob("*.yaml"):
            try:
                # 使用统一配置管理器加载
                config_data = self.config_manager.load_config_for_module(
                    f"node_functions/{config_file.name}", 
                    "workflow"
                )
                self._process_node_functions_config(config_data, config_file)
            except Exception as e:
                logger.error(f"加载节点函数配置失败 {config_file}: {e}")
```

#### 2.2 状态机配置加载器 (`src/core/workflow/graph/nodes/state_machine/state_machine_config_loader.py`)

**现有实现特点**:
- 直接使用 `yaml.safe_load()` 加载配置
- 缺少配置处理和验证

**修改方案**:
```python
class StateMachineWorkflowLoader:
    def __init__(self, config_manager: Optional[ConfigManager] = None):
        self.config_manager = config_manager or get_default_manager()
    
    def _load_yaml_file(self, config_path: str) -> Dict[str, Any]:
        # 使用统一配置管理器
        return self.config_manager.load_config_for_module(config_path, "workflow")
```

### 3. 工具模块 (`src/core/tools/loaders.py`)

**现有实现特点**:
- `DefaultToolLoader` 类
- 使用注入的 `config_loader.load()` 
- 按工具类型分类加载

**修改方案**:
```python
class DefaultToolLoader:
    def __init__(self, config_manager: ConfigManager, logger):
        self.config_manager = config_manager
        self.logger = logger
    
    def _load_tool_type_configs(self, tool_type: str) -> List[ToolConfig]:
        tool_configs = []
        
        # 使用统一配置管理器加载
        config_files = self.config_manager.list_config_files(f"tools/{tool_type}")
        
        for config_file in config_files:
            try:
                config_data = self.config_manager.load_config_for_module(
                    f"tools/{tool_type}/{config_file}", 
                    "tools"
                )
                tool_config = self._parse_tool_config(config_data)
                tool_configs.append(tool_config)
            except Exception as e:
                self.logger.error(f"加载工具配置文件失败 {config_file}: {e}")
        
        return tool_configs
```

### 4. 状态管理模块 (`src/core/state/config/settings.py`)

**现有实现特点**:
- `StateManagementConfig` 类
- 直接使用 `ConfigLoader`
- 默认配置定义

**修改方案**:
```python
class StateManagementConfig:
    def __init__(self, config_manager: Optional[ConfigManager] = None):
        self.config_manager = config_manager or get_default_manager()
        self.config_path = "configs/state_management.yaml"
        self._config: Dict[str, Any] = {}
        
        # 加载配置
        self._load_config()
    
    def _load_config(self) -> None:
        try:
            if self.config_manager.loader.exists(self.config_path):
                self._config = self.config_manager.load_config_for_module(
                    self.config_path, 
                    "state"
                )
                logger.info(f"已加载状态管理配置: {self.config_path}")
            else:
                logger.warning(f"配置文件不存在: {self.config_path}，使用默认配置")
                self._config = self._get_default_config()
        except Exception as e:
            logger.error(f"加载配置文件失败: {e}，使用默认配置")
            self._config = self._get_default_config()
```

### 5. 工具配置验证器 (`src/services/tools/validation/validators/config_validator.py`)

**现有实现特点**:
- `ConfigValidator` 类
- 使用注入的 `config_loader.load()`
- 工具特定的验证逻辑

**修改方案**:
```python
class ConfigValidator(IToolValidator):
    def __init__(self, config_manager: ConfigManager, logger: ILogger):
        self.config_manager = config_manager
        self.logger = logger
    
    def validate_config(self, config_path: str) -> ValidationResult:
        result = ValidationResult("unknown", "unknown", ValidationStatus.SUCCESS)
        
        try:
            # 使用统一配置管理器加载配置
            config_data = self.config_manager.load_config_for_module(config_path, "tools")
            result.metadata["config_data"] = config_data
            
            # 执行工具特定的验证逻辑
            self._validate_tool_config(config_data, result)
            
        except Exception as e:
            result.add_issue(ValidationStatus.ERROR, f"配置文件加载失败: {e}")
        
        return result
```

## 适配器架构设计

### 1. 基础适配器接口

```python
from abc import ABC, abstractmethod
from typing import Dict, Any, Optional

class BaseConfigAdapter(ABC):
    """配置适配器基类"""
    
    def __init__(self, base_manager: ConfigManager):
        self.base_manager = base_manager
    
    @abstractmethod
    def load_config(self, config_path: str, **kwargs) -> Dict[str, Any]:
        """加载配置的适配方法"""
        pass
    
    @abstractmethod
    def validate_config(self, config: Dict[str, Any]) -> bool:
        """验证配置的适配方法"""
        pass
```

### 2. 模块特定适配器

#### LLM适配器
```python
class LLMConfigAdapter(BaseConfigAdapter):
    """LLM模块配置适配器"""
    
    def __init__(self, base_manager: ConfigManager):
        super().__init__(base_manager)
        self.client_configs: Dict[str, LLMClientConfig] = {}
        self.module_config: Optional[LLMModuleConfig] = None
        self.validator = LLMConfigValidator()
    
    def load_config(self, config_path: str, **kwargs) -> Dict[str, Any]:
        config = self.base_manager.load_config_for_module(config_path, "llm")
        
        # LLM特定处理
        if config_path.endswith("_group.yaml"):
            self.module_config = LLMModuleConfig.from_dict(config)
        else:
            client_config = LLMClientConfig.from_dict(config)
            model_key = f"{client_config.model_type}:{client_config.model_name}"
            self.client_configs[model_key] = client_config
        
        return config
```

#### 工作流适配器
```python
class WorkflowConfigAdapter(BaseConfigAdapter):
    """工作流模块配置适配器"""
    
    def load_config(self, config_path: str, **kwargs) -> Dict[str, Any]:
        return self.base_manager.load_config_for_module(config_path, "workflow")
    
    def validate_config(self, config: Dict[str, Any]) -> bool:
        # 工作流特定验证逻辑
        return True
```

## 迁移策略

### 阶段1: 创建适配器
1. 实现基础适配器接口
2. 为每个模块创建特定适配器
3. 保持现有API兼容性

### 阶段2: 逐步迁移
1. 更新各模块使用适配器
2. 移除重复的配置加载代码
3. 保留模块特定功能

### 阶段3: 优化和清理
1. 移除不再需要的代码
2. 优化性能
3. 完善文档

## 依赖注入配置

```python
def register_module_adapters(container: IDependencyContainer) -> None:
    """注册模块适配器"""
    
    # 注册基础配置管理器
    container.register(ConfigManager, ConfigManager, lifetime=ServiceLifetime.SINGLETON)
    
    # 注册适配器工厂
    container.register(AdapterFactory, AdapterFactory, lifetime=ServiceLifetime.SINGLETON)
    
    # 注册模块特定适配器
    container.register(
        LLMConfigAdapter,
        lambda: LLMConfigAdapter(container.get(ConfigManager)),
        lifetime=ServiceLifetime.SINGLETON
    )
```

## 预期收益

1. **代码复用**: 消除重复的配置加载代码
2. **功能统一**: 所有模块享受统一的配置功能
3. **维护简化**: 配置逻辑集中管理
4. **性能提升**: 统一缓存和优化
5. **扩展性**: 新模块易于集成配置系统

## 风险控制

1. **向后兼容**: 通过适配器保持现有API
2. **渐进迁移**: 分阶段实施，降低风险
3. **充分测试**: 每个阶段都有完整测试
4. **回滚机制**: 保留原有代码作为备份