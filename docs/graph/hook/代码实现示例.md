# HookableNode 代码实现示例

## 直接继承方式

### 新节点开发示例

```python
"""新节点直接继承 HookableNode 示例"""

from typing import Dict, Any, Optional
from src.infrastructure.graph.nodes.hookable_node import HookableNode
from src.domain.agent.state import AgentState
from ..registry import NodeExecutionResult

class MyNewNode(HookableNode):
    """新的节点类直接继承 HookableNode"""
    
    def __init__(self, hook_manager: Optional[IHookManager] = None):
        """初始化新节点
        
        Args:
            hook_manager: Hook 管理器实例
        """
        super().__init__(hook_manager)
    
    @property
    def node_type(self) -> str:
        """节点类型标识"""
        return "my_new_node"
    
    def _execute_core(self, state: AgentState, config: Dict[str, Any]) -> NodeExecutionResult:
        """执行节点核心逻辑（子类必须实现）
        
        Args:
            state: 当前 Agent 状态
        config: 节点配置
        
        Returns:
            NodeExecutionResult: 执行结果
        """
        # 节点业务逻辑实现
        # 这里可以添加具体的节点逻辑
        
        # 示例：处理状态并返回结果
        processed_state = self._process_state(state, config)
        
        return NodeExecutionResult(
            state=processed_state,
            next_node="next_step",
            metadata={"processed_by": "my_new_node"}
        )
    
    def get_config_schema(self) -> Dict[str, Any]:
        """获取节点配置Schema"""
        return {
            "type": "object",
            "properties": {
                "processing_strategy": {
                    "type": "string",
                    "description": "处理策略",
                    "default": "default"
                },
                "max_processing_time": {
                    "type": "integer",
                    "description": "最大处理时间（毫秒）",
                    "default": 5000
                }
            },
            "required": []
        }
    
    def validate_config(self, config: Dict[str, Any]) -> List[str]:
        """验证节点配置"""
        errors = []
        
        # 验证处理策略
        strategy = config.get("processing_strategy", "default")
        if strategy not in ["default", "fast", "thorough"]:
            errors.append("processing_strategy 必须是 'default', 'fast', 或 'thorough"")
        }
        
        return errors
```

### 现有节点包装示例

```python
"""现有节点包装为支持 Hook 示例"""

from src.infrastructure.graph.nodes.hookable_node import create_hookable_node_class
from src.infrastructure.graph.nodes import ToolNode, LLMNode

# 创建支持 Hook 的工具节点类
HookableToolNode = create_hookable_node_class(ToolNode, hook_manager)

# 创建节点实例
node_instance = HookableToolNode(hook_manager=hook_manager)

# 现在 node_instance 支持所有 Hook 功能
```

## HookAwareGraphBuilder 自动转换机制

### 核心代码位置

在 `src/infrastructure/graph/hook_aware_builder.py` 第72-74行：

```python
node_class = self.node_registry.get_node_class(node_config.function_name)
if node_class:
    # 创建支持 Hook 的节点类
from .nodes.hookable_node import create_hookable_node_class
hookable_node_class = create_hookable_node_class(node_class, self._hook_manager)
```

## 配置示例

### 全局 Hook 配置

```yaml
# configs/hooks/global_hooks.yaml
global_hooks:
  - type: "logging"
    enabled: true
    config:
      log_level: "INFO"
      format: "json"

# 节点特定 Hook 配置

```yaml
# configs/hooks/llm_node_hooks.yaml
node_type: "llm_node"
inherit_global: true
hooks:
  - type: "performance_monitoring"
    enabled: true
    config:
      metrics: ["execution_time", "token_usage"]
```

## 实际应用场景

### 1. 性能监控 Hook

```python
class PerformanceMonitoringHook(INodeHook):
    """性能监控 Hook"""
    
    def __init__(self, hook_config: Dict[str, Any]) -> None:
        super().__init__(hook_config)
    
    def before_execute(self, context: HookContext) -> HookExecutionResult:
    """节点执行前监控"""
    start_time = time.time()
    
    return HookExecutionResult(
        should_continue=True,
        metadata={"start_time": start_time}
)
```

### 2. 日志记录 Hook

```python
class LoggingHook(INodeHook):
    """日志记录 Hook"""
    
    def after_execute(self, context: HookContext) -> HookExecutionResult:
    """节点执行后记录日志"""
    execution_time = time.time() - context.metadata.get("start_time", time.time()))
    
    return HookExecutionResult(
        should_continue=True,
        metadata={"execution_time": execution_time}
)
```

## 迁移指南

### 步骤 1：分析现有节点

```python
# 查看当前注册的节点类型
from src.infrastructure.graph.registry import get_global_registry
registry = get_global_registry()
available_nodes = registry.list_nodes()
```

### 步骤 2：选择继承方式

```python
# 新节点：直接继承
class NewNode(HookableNode):
    # 实现 _execute_core 方法
```

## 测试验证

### 单元测试示例

```python
def test_hookable_node_inheritance():
    """测试 HookableNode 继承"""
    
    # 创建 Hook 管理器
    hook_manager = NodeHookManager(config_loader)
    
    # 方式一：直接继承
    class MyDirectNode(HookableNode):
        def _execute_core(self, state, config):
        # 节点逻辑
        return NodeExecutionResult(state=state)
```

## 总结

通过以上示例，开发者可以根据具体需求选择最适合的继承方式，快速为节点添加 Hook 支持。